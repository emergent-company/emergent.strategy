services:
  # Infisical secrets loader - fetches secrets and writes to shared volume
  infisical-secrets:
    image: infisical/cli:latest
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        echo "ðŸ” Fetching secrets from Infisical..."
        echo "Environment: $${INFISICAL_ENVIRONMENT:-dev}"
        echo "Project ID: $${INFISICAL_PROJECT_ID}"
        echo "Path: /workspace"
        echo "---"
        echo "Debug: Checking environment variables..."
        echo "INFISICAL_TOKEN length: $${#INFISICAL_TOKEN}"
        echo "INFISICAL_TOKEN first 20 chars: $${INFISICAL_TOKEN:0:20}..."
        echo "INFISICAL_TOKEN set: $$([ -n "$$INFISICAL_TOKEN" ] && echo 'YES' || echo 'NO')"
        echo "---"
        
        # Export secrets using service token
        # Capture both stdout and stderr to see actual error messages
        ERROR_OUTPUT=$$(mktemp)
        infisical export \
          --token="$${INFISICAL_TOKEN}" \
          --env="$${INFISICAL_ENVIRONMENT:-dev}" \
          --projectId="$${INFISICAL_PROJECT_ID}" \
          --path="/workspace" \
          --format=dotenv > /secrets/.env.infisical 2> $$ERROR_OUTPUT
        
        EXIT_CODE=$$?
        if [ $$EXIT_CODE -eq 0 ]; then
          echo "âœ… Secrets written to /secrets/.env.infisical"
          echo "ðŸ“Š Total secrets fetched: $$(wc -l < /secrets/.env.infisical)"
        else
          echo "âŒ Failed to fetch secrets (exit code: $$EXIT_CODE)"
          echo "---"
          echo "Error output from Infisical CLI:"
          cat $$ERROR_OUTPUT
          echo "---"
          echo "Debug: Token length = $${#INFISICAL_TOKEN}"
          echo "Debug: Token format check: $$(echo $$INFISICAL_TOKEN | grep -o '^st\.' || echo 'INVALID FORMAT')"
          echo "Debug: All env vars:"
          env | grep INFISICAL || echo "No INFISICAL vars found"
          echo "---"
          echo "âš ï¸  WARNING: Creating empty secrets file to prevent container crash"
          echo "âš ï¸  Services will fail without secrets - this is for debugging only!"
          touch /secrets/.env.infisical
          rm -f $$ERROR_OUTPUT
          # Don't exit - keep container running for debugging
        fi
        rm -f $$ERROR_OUTPUT
        
        # Keep container running so volume persists
        tail -f /dev/null
    volumes:
      - infisical_secrets:/secrets
      - .:/current-dir:ro  # Mount docker directory for test scripts
    environment:
      # Self-hosted Infisical requires explicit API URL
      # Without this, CLI defaults to Infisical Cloud (app.infisical.com)
      - INFISICAL_API_URL=${INFISICAL_API_URL:-https://infiscal.kucharz.net}
      # Token must be set as env var for Infisical CLI
      - INFISICAL_TOKEN=${INFISICAL_TOKEN}
      - INFISICAL_ENVIRONMENT=${INFISICAL_ENVIRONMENT:-dev}
      - INFISICAL_PROJECT_ID=${INFISICAL_PROJECT_ID}
    healthcheck:
      # Only check file exists (not empty) to allow debugging when fetch fails
      test: ["CMD", "sh", "-c", "test -f /secrets/.env.infisical"]
      interval: 5s
      timeout: 5s
      retries: 10
    restart: unless-stopped

  db:
    image: pgvector/pgvector:pg16
    depends_on:
      infisical-secrets:
        condition: service_healthy
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        # Source secrets from Infisical sidecar before starting postgres
        set -a
        . /secrets/.env.infisical
        set +a
        # Start postgres with all config from Infisical
        exec docker-entrypoint.sh postgres \
          -c log_destination=stderr \
          -c logging_collector=on \
          -c log_directory=/var/log/postgresql \
          -c log_filename=postgresql-%Y-%m-%d.log \
          -c log_rotation_age=1d \
          -c log_truncate_on_rotation=on \
          -c log_statement=$${POSTGRES_LOG_STATEMENT:-none} \
          -c log_connections=on \
          -c log_disconnections=on \
          -c log_duration=off \
          -c log_line_prefix='%t [%p] %u@%d '
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/00-init.sql:ro
      - ./01-init-zitadel.sh:/docker-entrypoint-initdb.d/01-init-zitadel.sh:ro
      - ${DB_LOGS_PATH:-/home/emergent/db_logs}:/var/log/postgresql
      - infisical_secrets:/secrets:ro
    command: >
      postgres
      -c log_destination=stderr
      -c logging_collector=on
      -c log_directory=/var/log/postgresql
      -c log_filename=postgresql-%Y-%m-%d.log
      -c log_rotation_age=1d
      -c log_truncate_on_rotation=on
      -c log_statement=${POSTGRES_LOG_STATEMENT:-none}
      -c log_connections=on
      -c log_disconnections=on
      -c log_duration=off
      -c log_line_prefix='%t [%p] %u@%d '
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${POSTGRES_USER:-spec} -d ${POSTGRES_DB:-spec}",
        ]
      interval: 5s
      timeout: 5s
      retries: 10

  # Zitadel Identity Provider (dev)
  zitadel:
    image: ghcr.io/zitadel/zitadel:latest
    depends_on:
      db:
        condition: service_healthy
      infisical-secrets:
        condition: service_healthy
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        # Source secrets from Infisical sidecar volume
        set -a
        . /secrets/.env.infisical
        set +a
        # Start Zitadel with all config from Infisical
        exec /app/zitadel start-from-init --masterkeyFromEnv
    volumes:
      - .:/current-dir:delegated
      - ../secrets/bootstrap:/machinekey
      - infisical_secrets:/secrets:ro
    ports:
      - "${ZITADEL_HTTP_PORT:-8100}:8080" # Zitadel HTTP (API) - configurable to avoid conflicts
      - "${ZITADEL_LOGIN_PORT:-8101}:3000" # Zitadel Login v2 (Next.js) - configurable
    labels:
      - "traefik.enable=true"
      # HTTP router (redirects to HTTPS)
      - "traefik.http.routers.zitadel.rule=Host(`${ZITADEL_EXTERNALDOMAIN}`)"
      - "traefik.http.routers.zitadel.entrypoints=web"
      # HTTPS router
      - "traefik.http.routers.zitadel-https.rule=Host(`${ZITADEL_EXTERNALDOMAIN}`)"
      - "traefik.http.routers.zitadel-https.entrypoints=websecure"
      - "traefik.http.routers.zitadel-https.tls=true"
      - "traefik.http.routers.zitadel-https.tls.certresolver=letsencrypt"
      # Service configuration (required for both HTTP and HTTPS)
      - "traefik.http.services.zitadel.loadbalancer.server.port=8080"
      - "traefik.http.routers.zitadel.service=zitadel"
      - "traefik.http.routers.zitadel-https.service=zitadel"
    healthcheck:
      test: ["CMD", "/app/zitadel", "ready"]
      interval: 10s
      timeout: 60s
      retries: 5
      start_period: 10s
    user: "0"

  login:
    image: ghcr.io/zitadel/zitadel-login:latest
    restart: unless-stopped
    depends_on:
      zitadel:
        condition: service_healthy
      infisical-secrets:
        condition: service_healthy
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        # Source secrets from Infisical sidecar
        set -a
        . /secrets/.env.infisical
        set +a
        # Override specific environment variables for login service
        export ZITADEL_API_URL=http://localhost:$${ZITADEL_HTTP_PORT:-8100}
        export NEXT_PUBLIC_BASE_PATH=/ui/v2/login
        export ZITADEL_SERVICE_USER_TOKEN_FILE=/current-dir/login-client.pat
        # Start login service
        exec node server.js
    volumes:
      - .:/current-dir:ro
      - infisical_secrets:/secrets:ro
    network_mode: service:zitadel
volumes:
  pg_data:
  db_logs:
  infisical_secrets:
