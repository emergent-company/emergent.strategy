#!/usr/bin/env npx tsx
/**
 * Seed Emergent Product Framework (EPF) Template Pack
 * Creates a template pack for managing product, strategy, and operations using EPF.
 * 
 * This script creates:
 * - 11 Object Types: Objective, KeyResult, Assumption, WorkPackage, ValueModel, 
 *   ValueLayer, ValueComponent, ValueSubComponent, Artifact, AssessmentReport, CalibrationMemo
 * - 9 Relationship Types: HAS_KEY_RESULT, SUPPORTS, TESTS, CONTAINS_LAYER, 
 *   CONTAINS_COMPONENT, CONTAINS_SUB_COMPONENT, MAPS_TO, ASSESSES, CALIBRATES
 * - UI configurations for all object types
 * - Metadata with canonical value model references for Strategy, OrgOps, and Commercial tracks
 * - Example artifacts for OKR, Assumption, and Work Package
 * 
 * Usage: npx tsx scripts/seed-emergent-framework.ts
 * 
 * See docs/emergent_framework.md for full EPF documentation and canonical value models.
 */

import { config } from 'dotenv';
import { Client } from 'pg';
import { exit } from 'process';
import { validateEnvVars, DB_REQUIREMENTS, getDbConfig } from './lib/env-validator.js';

// Load environment variables
config();

interface CreateTemplatePackDto {
    name: string;
    version: string;
    description?: string;
    author?: string;
    object_type_schemas: Record<string, any>;
    relationship_type_schemas?: Record<string, any>;
    ui_configs?: Record<string, any>;
}

const EPF_TEMPLATE_PACK: CreateTemplatePackDto = {
    name: 'Emergent Product Framework',
    version: '1.0.0',
    description: 'A template pack for managing product, strategy, and operations using the Emergent Product Framework (EPF).',
    author: 'Spec Server Team',

    object_type_schemas: {
        Objective: {
            type: 'object',
            required: ['objective'],
            properties: {
                objective: {
                    type: 'string',
                    description: 'A qualitative, aspirational goal for the current cycle.',
                },
            },
        },
        KeyResult: {
            type: 'object',
            required: ['description'],
            properties: {
                description: {
                    type: 'string',
                    description: 'A measurable outcome that indicates progress toward an objective.',
                },
                target: {
                    type: 'string',
                    description: 'The specific target value for the key result (e.g., >60%, 3, >8).',
                },
            },
        },
        Assumption: {
            type: 'object',
            required: ['description'],
            properties: {
                description: {
                    type: 'string',
                    description: 'A falsifiable hypothesis representing one of the riskiest assumptions being tested.',
                },
            },
        },
        WorkPackage: {
            type: 'object',
            required: ['name', 'description', 'owner', 'status', 'output'],
            properties: {
                name: { type: 'string', description: 'The name of the work package.' },
                description: { type: 'string', description: 'A detailed description of the work package.' },
                owner: { type: 'string', description: 'The person or team responsible for the work package.' },
                status: {
                    type: 'string',
                    enum: ['ready', 'in_progress', 'completed', 'blocked'],
                    description: 'The current status of the work package.',
                },
                output: { type: 'string', description: 'The measurable output generated by this work package.' },
            },
        },
        ValueModel: {
            type: 'object',
            required: ['track_name', 'status'],
            properties: {
                track_name: {
                    type: 'string',
                    enum: ['Product', 'Strategy', 'OrgOps', 'Commercial'],
                    description: 'The specific track this value model belongs to.',
                },
                version: { type: 'string', description: 'The version of the value model.' },
                status: { type: 'string', description: 'The status of the value model (e.g., draft, active).' },
                description: { type: 'string', description: 'A high-level description of the value model.' },
            },
        },
        ValueLayer: {
            type: 'object',
            required: ['name', 'uvp', 'jtbd'],
            properties: {
                name: { type: 'string', description: 'The name of the value layer (L1).' },
                active: { type: 'boolean', description: 'Whether this layer is currently active.' },
                uvp: { type: 'string', description: 'The Unique Value Proposition of this layer.' },
                jtbd: { type: 'string', description: 'The primary "Job To Be Done" for this layer.' },
            },
        },
        ValueComponent: {
            type: 'object',
            required: ['name', 'uvp'],
            properties: {
                name: { type: 'string', description: 'The name of the value component (L2).' },
                active: { type: 'boolean', description: 'Whether this component is currently active.' },
                uvp: { type: 'string', description: 'The Unique Value Proposition of this component.' },
            },
        },
        ValueSubComponent: {
            type: 'object',
            required: ['name', 'uvp'],
            properties: {
                name: { type: 'string', description: 'The name of the value sub-component (L3).' },
                active: { type: 'boolean', description: 'Whether this sub-component is currently active.' },
                uvp: { type: 'string', description: 'The Unique Value Proposition of this sub-component.' },
                metric: { type: 'string', description: 'The key metric associated with this sub-component.' },
            },
        },
        Artifact: {
            type: 'object',
            required: ['type', 'description', 'url'],
            properties: {
                type: {
                    type: 'string',
                    enum: ['figma', 'github_repo', 'api_endpoint', 'document', 'other'],
                    description: 'The type of the implementation artifact.',
                },
                description: { type: 'string', description: 'A description of the artifact.' },
                url: { type: 'string', format: 'uri', description: 'A URL pointing to the artifact.' },
            },
        },
        AssessmentReport: {
            type: 'object',
            required: ['assessment'],
            properties: {
                assessment: { type: 'string', description: 'A data-driven assessment of performance against OKRs.' },
            },
        },
        CalibrationMemo: {
            type: 'object',
            required: ['decision', 'reasoning'],
            properties: {
                decision: {
                    type: 'string',
                    enum: ['persevere', 'pivot', 'pull_the_plug', 'pending_assessment'],
                    description: 'The final decision for the cycle.',
                },
                reasoning: { type: 'string', description: 'The reasoning behind the calibration decision.' },
            },
        },
    },

    relationship_type_schemas: {
        HAS_KEY_RESULT: {
            description: 'An Objective is measured by one or more Key Results.',
            sourceTypes: ['Objective'],
            targetTypes: ['KeyResult'],
            cardinality: 'one-to-many',
        },
        SUPPORTS: {
            description: 'A Work Package supports a Key Result.',
            sourceTypes: ['WorkPackage'],
            targetTypes: ['KeyResult'],
            cardinality: 'many-to-many',
        },
        TESTS: {
            description: 'A Work Package is designed to test an Assumption.',
            sourceTypes: ['WorkPackage'],
            targetTypes: ['Assumption'],
            cardinality: 'many-to-many',
        },
        CONTAINS_LAYER: {
            description: 'A Value Model contains multiple Value Layers.',
            sourceTypes: ['ValueModel'],
            targetTypes: ['ValueLayer'],
            cardinality: 'one-to-many',
        },
        CONTAINS_COMPONENT: {
            description: 'A Value Layer contains multiple Value Components.',
            sourceTypes: ['ValueLayer'],
            targetTypes: ['ValueComponent'],
            cardinality: 'one-to-many',
        },
        CONTAINS_SUB_COMPONENT: {
            description: 'A Value Component contains multiple Value Sub-Components.',
            sourceTypes: ['ValueComponent'],
            targetTypes: ['ValueSubComponent'],
            cardinality: 'one-to-many',
        },
        MAPS_TO: {
            description: 'A Value Sub-Component is mapped to a concrete Artifact.',
            sourceTypes: ['ValueSubComponent'],
            targetTypes: ['Artifact'],
            cardinality: 'one-to-many',
        },
        ASSESSES: {
            description: 'An Assessment Report assesses an Objective.',
            sourceTypes: ['AssessmentReport'],
            targetTypes: ['Objective'],
            cardinality: 'many-to-one',
        },
        CALIBRATES: {
            description: 'A Calibration Memo makes a decision about an Objective.',
            sourceTypes: ['CalibrationMemo'],
            targetTypes: ['Objective'],
            cardinality: 'many-to-one',
        },
    },

    ui_configs: {
        Objective: { icon: 'lucide--flag', color: '#4F46E5' },
        KeyResult: { icon: 'lucide--key', color: '#10B981' },
        Assumption: { icon: 'lucide--flask-conical', color: '#F59E0B' },
        WorkPackage: { icon: 'lucide--package', color: '#3B82F6' },
        ValueModel: { icon: 'lucide--library', color: '#6366F1' },
        ValueLayer: { icon: 'lucide--layers', color: '#8B5CF6' },
        ValueComponent: { icon: 'lucide--component', color: '#A855F7' },
        ValueSubComponent: { icon: 'lucide--box', color: '#D946EF' },
        Artifact: { icon: 'lucide--link', color: '#6B7280' },
        AssessmentReport: { icon: 'lucide--clipboard-check', color: '#14B8A6' },
        CalibrationMemo: { icon: 'lucide--compass', color: '#EC4899' },
        _metadata: {
            description: 'Canonical value models for Strategy, OrgOps, and Commercial tracks',
            documentation_ref: 'docs/emergent_framework.md',
            canonical_value_models: {
                strategy: {
                    track_name: 'Strategy',
                    version: '1.0.0',
                    status: 'active',
                    description: 'Defines, communicates, and executes the company\'s overarching strategy.',
                    layers: ['STRATEGIC ROADMAP', 'TACTICAL ROADMAP', 'STRATEGIC COMMUNICATIONS'],
                    components_count: 14
                },
                org_ops: {
                    track_name: 'OrgOps',
                    version: '1.0.0',
                    status: 'active',
                    description: 'Builds and maintains the company\'s operational and cultural engine.',
                    layers: ['TALENT MANAGEMENT', 'CULTURE & INTERNAL COMMUNICATIONS', 'FINANCIAL & LEGAL', 'FACILITIES & IT', 'COMPANY GOVERNANCE & COMPLIANCE', 'OPERATIONAL STRUCTURE'],
                    components_count: 24
                },
                commercial: {
                    track_name: 'Commercial',
                    version: '1.0.0',
                    status: 'active',
                    description: 'Drives market positioning, revenue generation, and partnerships.',
                    layers: ['BUSINESS DEVELOPMENT AND PARTNERSHIPS', 'BRAND & POSITIONING', 'SALES AND MARKETING'],
                    components_count: 13
                }
            },
            examples: {
                okr: {
                    id: 'okr-001',
                    objective: 'Validate that the Board Meeting MVP solves a critical pain point',
                    key_results: [
                        { id: 'kr-001', description: 'Achieve >60% activation rate for invited board members' },
                        { id: 'kr-002', description: 'Successfully conduct at least 3 end-to-end board meetings' },
                        { id: 'kr-003', description: 'Achieve user satisfaction score of >8' }
                    ]
                },
                assumption: {
                    id: 'asm-001',
                    description: 'We assume board administrators will find the process significantly easier than their current manual process'
                },
                work_package: {
                    id: 'wp-001',
                    name: 'Build Admin Meeting & Agenda Creation',
                    description: 'Develop the core functionality for an authenticated administrator to create a meeting event',
                    owner: 'eng_lead_tbd',
                    status: 'ready',
                    output: 'A functional UI and backend for meeting creation'
                }
            }
        }
    },
};

async function createDbConnection(): Promise<Client> {
    // Validate required environment variables with helpful error messages
    validateEnvVars(DB_REQUIREMENTS);

    // Use validated env vars with no fallbacks
    const dbConfig = getDbConfig();
    const client = new Client({
        ...dbConfig,
        ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,
    });
    await client.connect();
    return client;
}

async function checkExistingTemplatePack(client: Client): Promise<boolean> {
    const result = await client.query(
        'SELECT id FROM kb.graph_template_packs WHERE name = $1 AND version = $2',
        [EPF_TEMPLATE_PACK.name, EPF_TEMPLATE_PACK.version]
    );
    return result.rows.length > 0;
}

async function createEpfTemplatePack(client: Client): Promise<string> {
    const result = await client.query(
        `INSERT INTO kb.graph_template_packs (
            name, version, description, author,
            object_type_schemas, relationship_type_schemas,
            ui_configs, source
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id`,
        [
            EPF_TEMPLATE_PACK.name,
            EPF_TEMPLATE_PACK.version,
            EPF_TEMPLATE_PACK.description,
            EPF_TEMPLATE_PACK.author,
            JSON.stringify(EPF_TEMPLATE_PACK.object_type_schemas),
            JSON.stringify(EPF_TEMPLATE_PACK.relationship_type_schemas),
            JSON.stringify(EPF_TEMPLATE_PACK.ui_configs),
            'system'
        ]
    );
    return result.rows[0].id;
}

async function main() {
    console.log('üå± Starting Emergent Product Framework Template Pack Seeding...');
    let client: Client | null = null;
    try {
        client = await createDbConnection();
        console.log('‚úÖ Connected to database');

        const exists = await checkExistingTemplatePack(client);
        if (exists) {
            console.log('‚ö†Ô∏è  Emergent Product Framework template pack already exists - skipping creation');
            return;
        }

        const templatePackId = await createEpfTemplatePack(client);
        console.log(`‚úÖ Created Emergent Product Framework template pack with ID: ${templatePackId}`);

        const typeCount = Object.keys(EPF_TEMPLATE_PACK.object_type_schemas).length;
        const relationshipCount = Object.keys(EPF_TEMPLATE_PACK.relationship_type_schemas || {}).length;

        console.log('\nüìä Template Pack Summary:');
        console.log(`   Name: ${EPF_TEMPLATE_PACK.name}`);
        console.log(`   Version: ${EPF_TEMPLATE_PACK.version}`);
        console.log(`   Object Types: ${typeCount}`);
        console.log(`   Relationship Types: ${relationshipCount}`);
        console.log(`   Canonical Value Models: 3 (Strategy, OrgOps, Commercial)`);
        console.log(`   Example Artifacts: OKR, Assumption, Work Package`);

        console.log('\nüèÅ EPF Template Pack seeding completed successfully!');
        console.log('   You can now assign this template pack to projects via the admin interface.');
        console.log('   üìö See docs/emergent_framework.md for detailed canonical value models.');

    } catch (error) {
        console.error('‚ùå Error seeding EPF template pack:', error);
        exit(1);
    } finally {
        if (client) {
            await client.end();
            console.log('üìù Database connection closed');
        }
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    main().catch(console.error);
}

export default main;
