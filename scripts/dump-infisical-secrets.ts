#!/usr/bin/env npx tsx
/**
 * Dump Infisical secrets to .env.infisical file
 *
 * This script fetches secrets from Infisical and writes them to a local file.
 *
 * NOTE: Apps do NOT automatically load .env.infisical. After running this script,
 * copy the needed variables to .env.local for your local development, or use
 * --output=.env.local to write directly to .env.local.
 *
 * Usage:
 *   npx tsx scripts/dump-infisical-secrets.ts
 *   npx tsx scripts/dump-infisical-secrets.ts --environment=staging
 *   npx tsx scripts/dump-infisical-secrets.ts --output=.env.local
 *
 * Required env vars (in .env.local):
 *   INFISICAL_SITE_URL
 *   INFISICAL_CLIENT_ID
 *   INFISICAL_CLIENT_SECRET
 *   INFISICAL_PROJECT_ID
 */

import { config } from 'dotenv';
import { writeFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const ROOT_DIR = join(import.meta.dirname, '..');

config({ path: join(ROOT_DIR, '.env') });
config({ path: join(ROOT_DIR, '.env.local'), override: true });

interface InfisicalSecret {
  secretKey: string;
  secretValue: string;
}

interface CLIOptions {
  environment: string;
  output: string;
  folders: string[];
  dryRun: boolean;
}

function parseArgs(): CLIOptions {
  const args = process.argv.slice(2);
  const options: CLIOptions = {
    environment: process.env.INFISICAL_ENVIRONMENT || 'dev',
    output: join(ROOT_DIR, '.env.infisical'),
    folders: ['/workspace', '/server', '/admin'],
    dryRun: false,
  };

  for (const arg of args) {
    if (arg.startsWith('--environment=')) {
      options.environment = arg.split('=')[1];
    } else if (arg.startsWith('--output=')) {
      options.output = arg.split('=')[1];
      if (!options.output.startsWith('/')) {
        options.output = join(ROOT_DIR, options.output);
      }
    } else if (arg.startsWith('--folders=')) {
      options.folders = arg.split('=')[1].split(',');
    } else if (arg === '--dry-run') {
      options.dryRun = true;
    } else if (arg === '--help' || arg === '-h') {
      printHelp();
      process.exit(0);
    }
  }

  return options;
}

function printHelp(): void {
  console.log(`
Dump Infisical Secrets to .env.infisical

Usage:
  npx tsx scripts/dump-infisical-secrets.ts [options]

Options:
  --environment=<env>   Infisical environment (default: dev)
  --output=<path>       Output file path (default: .env.infisical)
  --folders=<list>      Comma-separated folder paths (default: /workspace,/server,/admin)
  --dry-run             Print secrets without writing to file
  --help, -h            Show this help message

Required Environment Variables (set in .env.local):
  INFISICAL_SITE_URL      Infisical server URL
  INFISICAL_CLIENT_ID     Machine identity client ID
  INFISICAL_CLIENT_SECRET Machine identity client secret
  INFISICAL_PROJECT_ID    Infisical project ID

Example:
  npx tsx scripts/dump-infisical-secrets.ts --environment=staging --output=.env.infisical.staging
`);
}

async function getAccessToken(
  siteUrl: string,
  clientId: string,
  clientSecret: string
): Promise<string> {
  const response = await fetch(`${siteUrl}/api/v1/auth/universal-auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ clientId, clientSecret }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Authentication failed (${response.status}): ${errorText}`);
  }

  const data = await response.json();
  return data.accessToken;
}

async function fetchSecretsFromFolder(
  accessToken: string,
  siteUrl: string,
  projectId: string,
  environment: string,
  folderPath: string
): Promise<Map<string, string>> {
  const secrets = new Map<string, string>();

  try {
    const url = new URL(`${siteUrl}/api/v3/secrets/raw`);
    url.searchParams.set('workspaceId', projectId);
    url.searchParams.set('environment', environment);
    url.searchParams.set('secretPath', folderPath);

    const response = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
    });

    if (!response.ok) {
      if (response.status === 404) {
        console.log(`   ‚ö†Ô∏è  Folder ${folderPath} not found (skipping)`);
        return secrets;
      }
      const errorText = await response.text();
      throw new Error(
        `Failed to fetch from ${folderPath} (${response.status}): ${errorText}`
      );
    }

    const data = await response.json();
    const secretList: InfisicalSecret[] = data.secrets || [];

    for (const secret of secretList) {
      secrets.set(secret.secretKey, secret.secretValue);
    }

    console.log(`   ‚úÖ Loaded ${secrets.size} secrets from ${folderPath}`);
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Error loading ${folderPath}: ${message}`);
  }

  return secrets;
}

function formatEnvFile(secrets: Map<string, string>): string {
  const lines: string[] = [
    '# Auto-generated by dump-infisical-secrets.ts',
    `# Generated at: ${new Date().toISOString()}`,
    '# DO NOT EDIT - Re-run the script to update',
    '#',
    '# Usage: This file is loaded by apps automatically when INFISICAL_ENABLED is not set',
    '',
  ];

  const sortedKeys = Array.from(secrets.keys()).sort();

  for (const key of sortedKeys) {
    const value = secrets.get(key)!;
    const needsQuotes =
      value.includes(' ') ||
      value.includes('"') ||
      value.includes("'") ||
      value.includes('\n');

    if (needsQuotes) {
      const escaped = value
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n');
      lines.push(`${key}="${escaped}"`);
    } else {
      lines.push(`${key}=${value}`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

async function main(): Promise<void> {
  const options = parseArgs();

  console.log('\nüîê Infisical Secret Dump\n');

  const siteUrl = process.env.INFISICAL_SITE_URL;
  const clientId = process.env.INFISICAL_CLIENT_ID;
  const clientSecret = process.env.INFISICAL_CLIENT_SECRET;
  const projectId = process.env.INFISICAL_PROJECT_ID;

  if (!siteUrl || !clientId || !clientSecret || !projectId) {
    console.error('‚ùå Missing required environment variables:');
    if (!siteUrl) console.error('   - INFISICAL_SITE_URL');
    if (!clientId) console.error('   - INFISICAL_CLIENT_ID');
    if (!clientSecret) console.error('   - INFISICAL_CLIENT_SECRET');
    if (!projectId) console.error('   - INFISICAL_PROJECT_ID');
    console.error('\nüí° Set these in .env.local');
    process.exit(1);
  }

  console.log(`   Site URL: ${siteUrl}`);
  console.log(`   Project ID: ${projectId}`);
  console.log(`   Environment: ${options.environment}`);
  console.log(`   Folders: ${options.folders.join(', ')}`);
  console.log(`   Output: ${options.output}`);
  console.log('');

  console.log('üîë Authenticating with Infisical...');
  const accessToken = await getAccessToken(siteUrl, clientId, clientSecret);
  console.log('   ‚úÖ Authentication successful\n');

  console.log('üì• Fetching secrets...');
  const allSecrets = new Map<string, string>();

  for (const folder of options.folders) {
    const folderSecrets = await fetchSecretsFromFolder(
      accessToken,
      siteUrl,
      projectId,
      options.environment,
      folder
    );

    for (const [key, value] of folderSecrets) {
      allSecrets.set(key, value);
    }
  }

  console.log(`\nüìä Total: ${allSecrets.size} unique secrets\n`);

  if (allSecrets.size === 0) {
    console.log('‚ö†Ô∏è  No secrets found. Nothing to write.');
    process.exit(0);
  }

  const envContent = formatEnvFile(allSecrets);

  if (options.dryRun) {
    console.log('üîç Dry run - secrets would be written:\n');
    console.log('--- BEGIN .env.infisical ---');
    console.log(envContent);
    console.log('--- END .env.infisical ---');
  } else {
    const existed = existsSync(options.output);
    writeFileSync(options.output, envContent, 'utf-8');
    console.log(`‚úÖ ${existed ? 'Updated' : 'Created'} ${options.output}`);
    console.log(`   Contains ${allSecrets.size} secrets`);
  }

  console.log('\nüéâ Done!\n');
}

main().catch((error: unknown) => {
  const message = error instanceof Error ? error.message : String(error);
  console.error(`\n‚ùå Fatal error: ${message}\n`);
  process.exit(1);
});
