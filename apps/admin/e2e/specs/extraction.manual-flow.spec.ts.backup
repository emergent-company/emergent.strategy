import { test, expect } from '../fixtures/app';
import { navigate } from '../utils/navigation';
import { expectNoRuntimeErrors } from '../utils/assertions';
import { ensureDevAuth, ensureActiveOrgAndProject } from '../utils/chat';
import type { Page } from '@playwright/test';

/**
 * E2E test for manual extraction flow
 * 
 * Tests the co        await test.step('Setup', async () => {
            await ensureDevAuth(page);
            await seedOrgProject(page);
            await stubOrgsBackend(page);
            await stubProjectsBackend(page);
            await stubDocumentsBackend(page);
            await stubExtractionJobsBackend(page);
        });

        await test.step('Navigate to Documents page', async () => {
            await navigate(page, '/admin/apps/documents');
            await expect(page).toHaveURL(/\/admin\/apps\/documents/);
        });

        await test.step('Navigate and open modal', async () => {ey:
 * 1. Navigate to Documents page
 * 2. Click "Extract" button on a document
 * 3. Configure extraction settings in modal
 * 4. Start extraction
 * 5. Verify job creation and navigation to detail page
 * 6. Watch job progress in real-time
 * 7. Verify completion and extracted entities
 */

/**
 * Stub the orgs backend to return mock orgs
 */
async function stubOrgsBackend(page: Page): Promise<void> {
    await page.route('**/orgs*', async (route) => {
        const method = route.request().method();
        if (method === 'OPTIONS') {
            return route.fulfill({
                status: 204,
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                    'Access-Control-Allow-Headers': 'authorization,content-type,x-org-id,x-project-id',
                    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
                },
            });
        }
        if (method === 'GET') {
            return route.fulfill({
                status: 200,
                contentType: 'application/json',
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                },
                body: JSON.stringify([
                    {
                        id: '22222222-2222-4222-8222-222222222222',
                        name: 'E2E Test Org',
                    },
                ]),
            });
        }
        return route.fallback();
    });
}

/**
 * Stub the projects backend to return mock projects
 */
async function stubProjectsBackend(page: Page): Promise<void> {
    // Log all requests to see what's happening
    page.on('request', request => {
        const url = request.url();
        if (url.includes('/projects')) {
            console.log('[TEST] Request to:', url, 'Method:', request.method());
        }
    });
    
    await page.route('**/projects*', async (route) => {
        console.log('[STUB] Intercepted /projects request:', route.request().url());
        const method = route.request().method();
        if (method === 'OPTIONS') {
            console.log('[STUB] Responding to OPTIONS /projects');
            return route.fulfill({
                status: 204,
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                    'Access-Control-Allow-Headers': 'authorization,content-type,x-org-id,x-project-id',
                    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
                },
            });
        }
        if (method === 'GET') {
            console.log('[STUB] Responding to GET /projects with mock data');
            return route.fulfill({
                status: 200,
                contentType: 'application/json',
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                },
                body: JSON.stringify([
                    {
                        id: '33333333-3333-4333-8333-333333333333',
                        name: 'E2E Test Project',
                        orgId: '22222222-2222-4222-8222-222222222222',
                    },
                ]),
            });
        }
        return route.fallback();
    });
}

/**
 * Stub the documents backend to return mock documents
 */
async function stubDocumentsBackend(page: Page): Promise<void> {
    const mockDocuments = [
        {
            id: 'doc-test-001',
            filename: 'Product Requirements.md',
            mime_type: 'text/markdown',
            size_bytes: 15360,
            created_at: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
            updated_at: new Date(Date.now() - 86400000).toISOString(),
            project_id: '33333333-3333-4333-8333-333333333333',
            org_id: '22222222-2222-4222-8222-222222222222',
            chunk_count: 12,
            ingestion_status: 'completed',
        },
        {
            id: 'doc-test-002',
            filename: 'Meeting Notes 2024-10-01.md',
            mime_type: 'text/markdown',
            size_bytes: 8192,
            created_at: new Date(Date.now() - 172800000).toISOString(), // 2 days ago
            updated_at: new Date(Date.now() - 172800000).toISOString(),
            project_id: '33333333-3333-4333-8333-333333333333',
            org_id: '22222222-2222-4222-8222-222222222222',
            chunk_count: 6,
            ingestion_status: 'completed',
        },
    ];

    // GET /documents (skip HTML document requests, only stub API calls)
    await page.route((url) => /\/documents($|\?)/.test(url.pathname), async (route) => {
        // Skip top-level navigation (resourceType 'document')
        if (route.request().resourceType() === 'document') {
            return route.fallback();
        }
        
        if (route.request().method() === 'GET') {
            return route.fulfill({
                status: 200,
                contentType: 'application/json',
                body: JSON.stringify({ documents: mockDocuments }),
            });
        }
        return route.fallback();
    });

    // GET /documents/:id/chunks
    await page.route('**/documents/*/chunks', async (route) => {
        if (route.request().method() === 'GET') {
            return route.fulfill({
                status: 200,
                contentType: 'application/json',
                body: JSON.stringify({
                    chunks: [
                        {
                            id: 'chunk-001',
                            text: 'The system SHALL support user authentication via OAuth 2.0...',
                            position: 0,
                        },
                        {
                            id: 'chunk-002',
                            text: 'DECISION: We will use PostgreSQL for the primary database...',
                            position: 1,
                        },
                    ],
                }),
            });
        }
        return route.fallback();
    });
}

/**
 * Stub extraction jobs backend with realistic job lifecycle
 */
async function stubExtractionJobsBackend(page: Page) {
    let jobStatus: 'pending' | 'running' | 'completed' = 'pending';
    let jobProgress = 0;
    let createdJobId: string | null = null;

    const mockExtractedEntities = [
        {
            id: 'obj-req-001',
            type: 'Requirement',
            name: 'OAuth 2.0 Authentication',
            description: 'The system SHALL support user authentication via OAuth 2.0',
            confidence: 0.92,
        },
        {
            id: 'obj-dec-001',
            type: 'Decision',
            name: 'PostgreSQL Database Selection',
            description: 'DECISION: We will use PostgreSQL for the primary database',
            confidence: 0.88,
        },
        {
            id: 'obj-feat-001',
            type: 'Feature',
            name: 'Real-time Notifications',
            description: 'Feature to send real-time notifications to users',
            confidence: 0.85,
        },
        {
            id: 'obj-task-001',
            type: 'Task',
            name: 'Implement User Profile Page',
            description: 'TODO: Create user profile management interface',
            confidence: 0.79,
        },
    ];

    // POST /admin/extraction-jobs (create job)
    await page.route('**/admin/extraction-jobs', async (route) => {
        if (route.request().method() === 'POST') {
            const body = route.request().postDataJSON();
            createdJobId = `job-${Date.now()}`;
            
            const newJob = {
                id: createdJobId,
                org_id: body.org_id,
                project_id: body.project_id,
                source_type: body.source_type,
                source_id: body.source_id,
                source_metadata: body.source_metadata,
                extraction_config: body.extraction_config,
                status: 'pending',
                progress_current: 0,
                progress_total: 0,
                items_processed: 0,
                items_successful: 0,
                items_failed: 0,
                entity_types_discovered: [],
                created_objects: [],
                error_details: null,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString(),
            };

            // Simulate job lifecycle in background
            setTimeout(() => {
                jobStatus = 'running';
                jobProgress = 0;
            }, 2000);

            setTimeout(() => {
                jobProgress = 50;
            }, 4000);

            setTimeout(() => {
                jobStatus = 'completed';
                jobProgress = 100;
            }, 6000);

            return route.fulfill({
                status: 201,
                contentType: 'application/json',
                body: JSON.stringify(newJob),
            });
        }
        return route.fallback();
    });

    // GET /admin/extraction-jobs/:id (get job detail)
    await page.route('**/admin/extraction-jobs/*', async (route) => {
        if (route.request().method() === 'GET' && createdJobId) {
            const jobId = route.request().url().split('/').pop()?.split('?')[0];
            
            if (jobId === createdJobId) {
                const job = {
                    id: createdJobId,
                    org_id: '22222222-2222-4222-8222-222222222222',
                    project_id: '33333333-3333-4333-8333-333333333333',
                    source_type: 'document',
                    source_id: 'doc-test-001',
                    source_metadata: {
                        filename: 'Product Requirements.md',
                        mime_type: 'text/markdown',
                    },
                    extraction_config: {
                        entity_types: ['Requirement', 'Decision', 'Feature', 'Task'],
                        confidence_threshold: 0.7,
                        entity_linking_strategy: 'fuzzy',
                        require_review: false,
                        send_notification: true,
                    },
                    status: jobStatus,
                    progress_current: jobStatus === 'completed' ? 12 : Math.floor(12 * (jobProgress / 100)),
                    progress_total: 12,
                    items_processed: jobStatus === 'completed' ? 4 : Math.floor(4 * (jobProgress / 100)),
                    items_successful: jobStatus === 'completed' ? 4 : Math.floor(4 * (jobProgress / 100)),
                    items_failed: 0,
                    entity_types_discovered: jobStatus === 'completed' 
                        ? ['Requirement', 'Decision', 'Feature', 'Task']
                        : jobStatus === 'running' && jobProgress > 50
                        ? ['Requirement', 'Decision']
                        : [],
                    created_objects: jobStatus === 'completed' ? mockExtractedEntities : [],
                    error_details: null,
                    created_at: new Date(Date.now() - 10000).toISOString(),
                    updated_at: new Date().toISOString(),
                };

                return route.fulfill({
                    status: 200,
                    contentType: 'application/json',
                    body: JSON.stringify(job),
                });
            }
        }
        return route.fallback();
    });

    // GET /admin/extraction-jobs (list jobs)
    await page.route('**/admin/extraction-jobs?*', async (route) => {
        if (route.request().method() === 'GET') {
            return route.fulfill({
                status: 200,
                contentType: 'application/json',
                body: JSON.stringify({
                    jobs: [],
                    total: 0,
                    page: 1,
                    limit: 20,
                }),
            });
        }
        return route.fallback();
    });
}

test.describe('Manual Extraction Flow - Complete E2E', () => {

    test('completes full manual extraction journey', async ({ page, consoleErrors, pageErrors }) => {
        await test.step('Setup: Seed config and stub backends', async () => {
            await ensureDevAuth(page);
            await seedOrgProject(page);
            await stubDocumentsBackend(page);
            await stubExtractionJobsBackend(page);
        });

        await test.step('Navigate to Documents page', async () => {
            await navigate(page, '/admin/apps/documents');
            await expect(page).toHaveURL(/\/admin\/apps\/documents/);
            
            // Wait for page heading or breadcrumb to load
            const pageTitle = page.getByText(/documents/i).first();
            await expect(pageTitle).toBeVisible({ timeout: 10_000 });
        });

        await test.step('Verify document is visible in list', async () => {
            // Look for document name (could be in table, card, or list)
            const docName = page.getByText('Product Requirements.md');
            await expect(docName).toBeVisible({ timeout: 15_000 });
        });

        await test.step('Click Extract button on first document', async () => {
            // Find Extract button (has sparkles icon: lucide--sparkles)
            const extractButton = page.locator('button').filter({ 
                has: page.locator('.lucide--sparkles') 
            }).first();
            
            await expect(extractButton).toBeVisible({ timeout: 5_000 });
            await extractButton.click();
        });

        await test.step('Verify extraction config modal opens', async () => {
            // Wait for modal backdrop
            const modalBackdrop = page.locator('.modal-backdrop, [role="dialog"]').first();
            await modalBackdrop.waitFor({ state: 'visible', timeout: 5_000 });
            
            // Verify modal heading
            const modalHeading = page.getByText(/configure extraction/i);
            await expect(modalHeading).toBeVisible({ timeout: 3_000 });
        });

        await test.step('Configure extraction settings', async () => {
            // Verify entity types section is visible
            const entityTypesHeading = page.getByText(/entity types/i).first();
            await expect(entityTypesHeading).toBeVisible();
            
            // Entity type checkboxes should be visible and some checked by default
            const requirementCheckbox = page.getByRole('checkbox', { name: /requirement/i });
            await expect(requirementCheckbox).toBeVisible();
            
            // Verify confidence threshold slider
            const confidenceSlider = page.locator('input[type="range"]').first();
            await expect(confidenceSlider).toBeVisible();
            
            // Optionally adjust confidence (set to 70%)
            await confidenceSlider.fill('0.7');
            
            // Verify entity linking strategy radio buttons
            const fuzzyRadio = page.getByRole('radio', { name: /fuzzy/i });
            await expect(fuzzyRadio).toBeVisible();
            
            // Select fuzzy linking
            await fuzzyRadio.click();
            
            // Verify notification toggle
            const notifyToggle = page.locator('input[type="checkbox"]').filter({ 
                has: page.locator('~ *', { hasText: /notification/i }) 
            }).first();
            await expect(notifyToggle).toBeVisible();
        });

        await test.step('Start extraction', async () => {
            // Find and click "Start Extraction" button
            const startButton = page.getByRole('button', { name: /start extraction/i });
            await expect(startButton).toBeVisible();
            await startButton.click();
        });

        await test.step('Verify navigation to job detail page', async () => {
            // Should navigate to /admin/extraction-jobs/{jobId}
            await expect(page).toHaveURL(/\/admin\/extraction-jobs\/job-\d+/, { timeout: 10_000 });
        });

        await test.step('Verify job detail page loads with pending status', async () => {
            // Status badge should show "Pending" or "Running"
            const statusBadge = page.locator('.badge').filter({ 
                hasText: /pending|running/i 
            }).first();
            await expect(statusBadge).toBeVisible({ timeout: 5_000 });
            
            // Source information should be visible
            const sourceHeading = page.getByText(/source/i).first();
            await expect(sourceHeading).toBeVisible();
            
            const documentName = page.getByText('Product Requirements.md');
            await expect(documentName).toBeVisible();
        });

        await test.step('Watch job progress update to running', async () => {
            // Wait for status to change to "Running"
            // (page polls every 5 seconds)
            const runningBadge = page.locator('.badge').filter({ 
                hasText: /running/i 
            }).first();
            
            await expect(runningBadge).toBeVisible({ timeout: 15_000 });
            
            // Progress bar should appear
            const progressBar = page.locator('progress, .progress').first();
            await expect(progressBar).toBeVisible({ timeout: 3_000 });
        });

        await test.step('Wait for job completion', async () => {
            // Wait for status to change to "Completed"
            const completedBadge = page.locator('.badge').filter({ 
                hasText: /completed/i 
            }).first();
            
            await expect(completedBadge).toBeVisible({ timeout: 20_000 });
        });

        await test.step('Verify extracted entities are visible', async () => {
            // Check for "Discovered Entity Types" section
            const discoveredHeading = page.getByText(/discovered entity types/i);
            await expect(discoveredHeading).toBeVisible({ timeout: 5_000 });
            
            // Should show entity type badges
            const requirementBadge = page.locator('.badge').filter({ hasText: /requirement/i }).first();
            const decisionBadge = page.locator('.badge').filter({ hasText: /decision/i }).first();
            
            await expect(requirementBadge).toBeVisible({ timeout: 3_000 });
            await expect(decisionBadge).toBeVisible();
            
            // Check for "Created Objects" section
            const createdObjectsHeading = page.getByText(/created objects/i);
            await expect(createdObjectsHeading).toBeVisible();
            
            // Should show at least one extracted entity
            const firstEntity = page.getByText(/OAuth 2\.0 Authentication|PostgreSQL Database/i).first();
            await expect(firstEntity).toBeVisible({ timeout: 3_000 });
        });

        await test.step('Verify statistics are correct', async () => {
            // Look for statistics section
            const statsHeading = page.getByText(/statistics|stats/i).first();
            await expect(statsHeading).toBeVisible();
            
            // Items processed should be 4
            const processedCount = page.getByText(/4/).first();
            await expect(processedCount).toBeVisible();
            
            // Success count should be 4
            const successCount = page.locator('text=/4.*successful|successful.*4/i').first();
            await expect(successCount).toBeVisible({ timeout: 3_000 });
        });

        await test.step('Click on extracted entity to view in graph', async () => {
            // Find first entity link
            const entityLink = page.locator('a[href*="/admin/objects"]').first();
            
            // Verify it exists but don't click (would navigate away)
            await expect(entityLink).toBeVisible({ timeout: 3_000 });
            
            // Just verify the link href is correct
            const href = await entityLink.getAttribute('href');
            expect(href).toContain('/admin/objects');
        });

        await test.step('No console or page errors', async () => {
            expectNoRuntimeErrors('manual extraction flow', consoleErrors, pageErrors);
        });
    });

    test('modal can be cancelled without creating job', async ({ page, consoleErrors, pageErrors }) => {
        await test.step('Setup', async () => {
            await ensureDevAuth(page);
            await ensureActiveOrgAndProject(page);
            await stubDocumentsBackend(page);
            await stubExtractionJobsBackend(page);
        });

        await test.step('Navigate and open modal', async () => {
            await navigate(page, '/admin/apps/documents');
            
            const extractButton = page.locator('button').filter({ 
                has: page.locator('.lucide--sparkles') 
            }).first();
            await extractButton.waitFor({ state: 'visible', timeout: 10_000 });
            await extractButton.click();
        });

        await test.step('Verify modal is open', async () => {
            const modalHeading = page.getByText(/configure extraction/i);
            await expect(modalHeading).toBeVisible({ timeout: 5_000 });
        });

        await test.step('Click Cancel button', async () => {
            const cancelButton = page.getByRole('button', { name: /cancel/i });
            await expect(cancelButton).toBeVisible();
            await cancelButton.click();
        });

        await test.step('Verify modal closes and stays on documents page', async () => {
            // Modal should close
            const modalHeading = page.getByText(/configure extraction/i);
            await expect(modalHeading).not.toBeVisible({ timeout: 5_000 });
            
            // Should still be on documents page
            await expect(page).toHaveURL(/\/admin\/apps\/documents/);
        });

        await test.step('No console or page errors', async () => {
            expectNoRuntimeErrors('modal cancellation', consoleErrors, pageErrors);
        });
    });

    test('displays validation message for no entity types selected', async ({ page, consoleErrors, pageErrors }) => {
        await test.step('Setup', async () => {
            await ensureDevAuth(page);
            await ensureActiveOrgAndProject(page);
            await stubDocumentsBackend(page);
            await stubExtractionJobsBackend(page);
        });

        await test.step('Open extraction modal', async () => {
            await navigate(page, '/admin/apps/documents');
            
            const extractButton = page.locator('button').filter({ 
                has: page.locator('.lucide--sparkles') 
            }).first();
            await extractButton.waitFor({ state: 'visible', timeout: 10_000 });
            await extractButton.click();
        });

        await test.step('Uncheck all entity types', async () => {
            // Find all entity type checkboxes that are checked
            const allCheckboxes = page.getByRole('checkbox');
            const count = await allCheckboxes.count();
            
            // Uncheck all that are checked
            for (let i = 0; i < count; i++) {
                const checkbox = allCheckboxes.nth(i);
                if (await checkbox.isChecked()) {
                    await checkbox.click();
                }
            }
        });

        await test.step('Try to start extraction', async () => {
            const startButton = page.getByRole('button', { name: /start extraction/i });
            
            // Button should be disabled or show validation message
            const isDisabled = await startButton.isDisabled();
            
            if (!isDisabled) {
                // If button is not disabled, it should show validation message on click
                await startButton.click();
                
                // Look for validation message
                const validationMessage = page.getByText(/select at least one|no entity types/i);
                await expect(validationMessage).toBeVisible({ timeout: 3_000 });
            } else {
                // Button is disabled as expected
                expect(isDisabled).toBe(true);
            }
        });

        await test.step('No console or page errors', async () => {
            expectNoRuntimeErrors('validation check', consoleErrors, pageErrors);
        });
    });
});
