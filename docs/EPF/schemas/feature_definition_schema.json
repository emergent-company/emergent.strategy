{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "feature_definition_schema.json",
  "title": "EPF Feature Definition Schema",
  "version": "2.0.0",
  "description": "Schema for validating feature definition files that bridge EPF strategy to implementation tools. Follows lean documentation principles - git handles versioning. Supports rich value narratives, design guidance, and architecture patterns. Version 2.0: Enhanced with prescriptive quality constraints (exactly 4 personas, 3-paragraph narratives, top-level scenarios, required context fields, rich dependencies).",
  "type": "object",
  "required": ["id", "name", "slug", "status", "strategic_context", "definition"],
  "additionalProperties": false,
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^fd-[0-9]+$",
      "description": "Unique identifier for the feature definition (e.g., fd-001)"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "description": "Human-readable feature name"
    },
    "slug": {
      "type": "string",
      "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
      "description": "URL-safe identifier for the feature (e.g., digital-twin-ecosystem)"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "ready", "in-progress", "delivered"],
      "description": "Current status of the feature definition"
    },
    "strategic_context": {
      "type": "object",
      "description": "Loose references for traceability to strategic artifacts",
      "required": ["contributes_to", "tracks"],
      "properties": {
        "contributes_to": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^(Product|Commercial|Strategy|OrgOps)\\.[A-Za-z]+\\.[A-Za-z]+",
            "description": "Value model path (e.g., Product.Operate.Monitoring)"
          },
          "minItems": 1,
          "description": "Which value model L2/L3 paths receive value from this feature (N:M mapping)"
        },
        "tracks": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["product", "strategy", "org_ops", "commercial"]
          },
          "minItems": 1,
          "description": "Which roadmap track(s) this feature belongs to"
        },
        "assumptions_tested": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^asm-(p|s|o|c)-[0-9]+$",
            "description": "Assumption ID from roadmap (e.g., asm-p-001)"
          },
          "description": "Which assumptions from the roadmap this feature helps validate"
        }
      }
    },
    "definition": {
      "type": "object",
      "description": "Core feature definition",
      "required": ["job_to_be_done", "solution_approach", "capabilities"],
      "properties": {
        "job_to_be_done": {
          "type": "string",
          "minLength": 10,
          "description": "The job-to-be-done format: When [situation], I want to [motivation], so I can [expected outcome]."
        },
        "solution_approach": {
          "type": "string",
          "minLength": 10,
          "description": "High-level description of how this feature works from user's perspective"
        },
        "capabilities": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "name", "description"],
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^cap-[0-9]+$"
              },
              "name": {
                "type": "string"
              },
              "description": {
                "type": "string"
              }
            }
          },
          "minItems": 1,
          "description": "Key capabilities this feature provides"
        },
        "value_propositions": {
          "type": "array",
          "minItems": 4,
          "maxItems": 4,
          "items": {
            "type": "object",
            "required": ["persona", "current_situation", "transformation_moment", "emotional_resolution"],
            "properties": {
              "persona": {
                "type": "string",
                "description": "The user persona (e.g., 'Compliance Officer', 'Board Secretary', 'CFO')"
              },
              "current_situation": {
                "type": "string",
                "minLength": 200,
                "description": "Rich narrative paragraph (200+ chars) describing the persona's current frustrations and pain points. Must include: character name, specific metrics or time costs, concrete scenarios. Example: 'Sarah Martinez, Compliance Officer at TechFlow Inc., spends 15-20 hours per quarter manually compiling regulatory updates from 8 different sources...'"
              },
              "transformation_moment": {
                "type": "string",
                "minLength": 200,
                "description": "Rich narrative paragraph (200+ chars) describing the first concrete moment of value delivery. Must include: specific action, immediate benefit, measurable improvement. Example: 'On Monday morning, Sarah opens the Compliance Dashboard and sees all 8 regulatory sources automatically aggregated with AI-powered categorization...'"
              },
              "emotional_resolution": {
                "type": "string",
                "minLength": 200,
                "description": "Rich narrative paragraph (200+ chars) describing the long-term emotional transformation and sustained value. Must include: emotional state change, new capabilities, strategic outcomes. Example: 'Three months later, Sarah has reclaimed 60 hours per quarter. The anxiety of missing critical updates has been replaced by confidence...'"
              }
            }
          },
          "description": "Exactly 4 persona-specific value narratives (WHY this feature matters). Each narrative uses 3-paragraph structure: current_situation → transformation_moment → emotional_resolution. This captures full user journey from pain to transformation to lasting value."
        },
        "architecture_patterns": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["name", "description"],
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the architectural pattern (e.g., 'Attachable Services', 'Event Sourcing')"
              },
              "description": {
                "type": "string",
                "description": "Explanation of the pattern and why it's used"
              },
              "components": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Key components that implement this pattern"
              }
            }
          },
          "description": "Core architectural innovations or patterns that define how this feature works"
        }
      }
    },
    "implementation": {
      "type": "object",
      "description": "Implementation guidance for spec-driven tools to consume",
      "properties": {
        "design_guidance": {
          "type": "object",
          "description": "UX philosophy and design principles for this feature",
          "properties": {
            "principles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Core design principles (e.g., 'Principle of Least Astonishment', 'Progressive Disclosure')"
            },
            "inspirations": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Products or patterns to draw inspiration from (e.g., 'Google Calendar', 'Notion')"
            },
            "interaction_patterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Key interaction patterns to use (e.g., 'drag-and-drop', 'inline editing', 'command palette')"
            }
          }
        },
        "contexts": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "type", "name", "description"],
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^ctx-[0-9]+$"
              },
              "type": {
                "type": "string",
                "enum": ["ui", "email", "notification", "api", "report", "integration"]
              },
              "name": {
                "type": "string"
              },
              "description": {
                "type": "string"
              },
              "key_interactions": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "minItems": 1,
                "description": "Required: Key user interactions in this context (what users DO). Must have at least 1 interaction. Example: ['Click Add Document button', 'Drag and drop PDF file', 'Review extraction results']"
              },
              "data_displayed": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "minItems": 1,
                "description": "Required: Key data or information shown in this context (what users SEE). Must have at least 1 data element. Example: ['Document list with status', 'Extraction progress bar', 'Confidence scores per entity']"
              }
            },
            "required": ["id", "type", "name", "description", "key_interactions", "data_displayed"]
          },
          "description": "User-facing contexts (UI screens, emails, notifications, etc.)"
        },
        "scenarios": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "required": ["id", "name", "actor", "context", "trigger", "action", "outcome", "acceptance_criteria"],
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^scn-[0-9]+$"
              },
              "name": {
                "type": "string",
                "minLength": 10,
                "description": "Human-readable scenario name (e.g., 'Upload and Process Compliance Document')"
              },
              "jtbd_category": {
                "type": "string",
                "description": "The job-to-be-done category this scenario supports (for grouping related scenarios)"
              },
              "actor": {
                "type": "string",
                "description": "Who performs this scenario (persona name or role)"
              },
              "context": {
                "type": "string",
                "minLength": 20,
                "description": "Where and when this scenario occurs (situation, preconditions)"
              },
              "trigger": {
                "type": "string",
                "minLength": 10,
                "description": "What initiates this scenario (event, user action, scheduled task)"
              },
              "action": {
                "type": "string",
                "minLength": 20,
                "description": "Step-by-step actions taken by the actor"
              },
              "outcome": {
                "type": "string",
                "minLength": 20,
                "description": "Expected result and value delivered"
              },
              "acceptance_criteria": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "minItems": 1,
                "description": "Testable conditions that must be true for scenario success"
              }
            }
          },
          "description": "Top-level scenarios array (MUST NOT be embedded in contexts). Key user scenarios following actor → context → trigger → action → outcome pattern. These should be concrete, testable flows that implement the job-to-be-done."
        },
        "external_integrations": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["name", "purpose"],
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the external system (e.g., 'Google Calendar', 'Outlook', 'Slack')"
              },
              "purpose": {
                "type": "string",
                "description": "Why this integration exists and what value it provides"
              },
              "direction": {
                "type": "string",
                "enum": ["inbound", "outbound", "bidirectional"],
                "description": "Data flow direction"
              }
            }
          },
          "description": "External systems this feature integrates with"
        }
      }
    },
    "boundaries": {
      "type": "object",
      "description": "Constraints and non-goals",
      "properties": {
        "non_goals": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "What this feature explicitly does NOT do"
        },
        "constraints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Technical or business constraints"
        }
      }
    },
    "dependencies": {
      "type": "object",
      "description": "Dependencies on other features - use rich objects with id, name, and reason to explain WHY dependencies exist",
      "properties": {
        "requires": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "name", "reason"],
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^fd-[0-9]+$",
                "description": "Feature definition ID (e.g., fd-001)"
              },
              "name": {
                "type": "string",
                "minLength": 10,
                "description": "Human-readable name of the required feature"
              },
              "reason": {
                "type": "string",
                "minLength": 30,
                "description": "Explanation of WHY this dependency exists (30+ chars). Be specific about what capability is needed."
              }
            }
          },
          "description": "Features that must exist before this one can be implemented. Each dependency includes id, name, and reason."
        },
        "enables": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "name", "reason"],
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^fd-[0-9]+$",
                "description": "Feature definition ID (e.g., fd-003)"
              },
              "name": {
                "type": "string",
                "minLength": 10,
                "description": "Human-readable name of the enabled feature"
              },
              "reason": {
                "type": "string",
                "minLength": 30,
                "description": "Explanation of HOW this feature enables the other (30+ chars). Be specific about what capability is provided."
              }
            }
          },
          "description": "Features that become possible once this one exists. Each dependency includes id, name, and reason."
        }
      }
    },
    "implementation_references": {
      "type": "object",
      "description": "Links to implementation specs created by external spec-driven tools. This enables bi-directional traceability between EPF and implementation.",
      "properties": {
        "tool_name": {
          "type": "string",
          "description": "Name of the spec-driven tool (e.g., 'openspec', 'specit', 'cursor-agent')"
        },
        "specs": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id"],
            "properties": {
              "id": {
                "type": "string",
                "description": "Spec ID in the tool's system"
              },
              "path": {
                "type": "string",
                "description": "Relative path to spec file (from repo root)"
              },
              "url": {
                "type": "string",
                "format": "uri",
                "description": "URL if hosted externally (GitHub issue, Notion, etc.)"
              },
              "capability_coverage": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^cap-[0-9]+$"
                },
                "description": "Which EPF capabilities this spec implements"
              },
              "scenario_coverage": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^scn-[0-9]+$"
                },
                "description": "Which EPF scenarios have tests in this spec"
              },
              "status": {
                "type": "string",
                "enum": ["planned", "in-progress", "implemented", "tested"],
                "description": "Implementation status of this spec"
              }
            }
          },
          "description": "List of implementation specs created for this feature"
        },
        "last_sync": {
          "type": "string",
          "format": "date-time",
          "description": "When implementation references were last updated"
        },
        "coverage_summary": {
          "type": "object",
          "description": "Summary of implementation coverage",
          "properties": {
            "capabilities_covered": {
              "type": "integer",
              "description": "Number of capabilities with implementation"
            },
            "capabilities_total": {
              "type": "integer",
              "description": "Total number of capabilities in this feature"
            },
            "scenarios_tested": {
              "type": "integer",
              "description": "Number of scenarios with test coverage"
            },
            "scenarios_total": {
              "type": "integer",
              "description": "Total number of scenarios in this feature"
            }
          }
        }
      }
    }
  }
}
