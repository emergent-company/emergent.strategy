id: "fd-012"
name: "CLI for Local Workflow Testing"
slug: "cli-local-workflow-testing"
status: "draft"

strategic_context:
  problem_statement: |
    Developers and DevOps engineers cannot test EPF Runtime workflows locally before deploying to CI/CD pipelines or production. They must push changes to Git, wait for CI to run, and debug failures through logs—adding 15-30 minutes per iteration. Local testing requires manually calling API endpoints via curl with complex JSON payloads, which is error-prone and time-consuming. No command-line tool exists for common workflows (validate artifact, initiate workflow, check status), forcing engineers to memorize API paths and authentication schemes. Teams waste 4-6 hours per week on "test in CI" debugging cycles that could be caught locally.
  
  market_context: |
    Modern developer tools prioritize local-first workflows—Docker Compose, Terraform, kubectl all provide rich CLI experiences for local testing before remote deployment. CLIs have become the primary interface for infrastructure and workflow orchestration tools. Our opportunity is to bring Docker-quality developer experience to EPF workflows, enabling confident local testing and rapid iteration before CI/CD integration.
  
  success_metrics:
    - metric: "Local test iteration time"
      target: "Complete validate → initiate → status check cycle in <60 seconds locally"
      measurement: "Time from 'epf-runtime validate' to 'epf-runtime status complete' for test workflow"
    - metric: "CI debugging reduction"
      target: "50% reduction in 'test in CI' failures (currently 8-10 per week per team)"
      measurement: "Track CI pipeline failures attributed to EPF workflow issues before/after CLI adoption"
    - metric: "CLI adoption rate"
      target: "80% of EPF Runtime API users also use CLI for local testing within 2 weeks"
      measurement: "Track unique API keys used via CLI vs direct API calls"

definition:
  job_to_be_done: >
    When I'm developing or debugging EPF workflow integrations, I want a command-line tool that wraps API calls in simple commands, so I can test workflows locally, validate artifacts instantly, and iterate rapidly without waiting for CI/CD pipelines.

  solution_approach: >
    A Node.js CLI tool (npm package) that provides intuitive commands for EPF Runtime operations: 'validate' (artifact validation), 'run' (initiate workflow), 'status' (check progress), 'logs' (view workflow logs). CLI reads configuration from .epf-runtime.yaml (API endpoint, key, workspace), handles authentication automatically, formats API responses in developer-friendly output (colored tables, progress bars), and supports JSON output for scripting. Think "heroku CLI for EPF workflows" - opinionated, helpful, works everywhere.

  capabilities:
    - id: "cap-012-001"
      name: "Artifact Validation Command"
      description: >
        'epf-runtime validate <file>' command calls validation API with file content, displays errors in terminal with syntax highlighting and line numbers. Exit code 0 if valid, 1 if invalid (integrates with CI scripts).
    
    - id: "cap-012-002"
      name: "Workflow Execution Command"
      description: >
        'epf-runtime run <phase>' command initiates workflow via API, displays workflow ID and monitoring URL. Supports --watch flag to stream status updates in real-time. Can pass initial data via --data flag or stdin pipe.
    
    - id: "cap-012-003"
      name: "Status Monitoring Command"
      description: >
        'epf-runtime status <workflow-id>' command fetches workflow status via API, displays progress as formatted table with step names, status (pending/running/complete), and timestamps. Supports --watch for continuous monitoring.
    
    - id: "cap-012-004"
      name: "Configuration Management"
      description: >
        'epf-runtime config' command manages .epf-runtime.yaml configuration (API endpoint, key, workspace). Supports environment variable overrides (EPF_RUNTIME_API_KEY) for CI integration. Config file can be committed to Git (minus secrets) for team sharing.

  personas:
    - name: "Marcus Chen, AI Autonomy Engineer at AutoPlan AI"
      current_situation: |
        Marcus develops autonomous agents that call EPF Runtime API. During development, he writes agent code, runs it, discovers API call failures, reads error messages, fixes code, and repeats. Debugging API integration requires understanding HTTP status codes, JSON error formats, and API authentication. He uses curl for manual API testing but must reconstruct complex JSON payloads, remember API paths (/api/workflows vs /api/validate), and format responses with jq for readability. Each test iteration takes 5-10 minutes (construct curl, execute, parse response). He cannot easily test workflows end-to-end locally—must deploy agent to staging environment to test full workflow lifecycle.
      
      transformation_moment: |
        With the CLI, Marcus runs 'epf-runtime validate north-star.yaml' to test artifact validation locally. CLI displays errors with colored formatting and line numbers, matching his IDE's error display. He runs 'epf-runtime run ready --data north-star.yaml --watch' to initiate workflow and stream status updates in terminal. CLI shows progress bars, step completion timestamps, and success/failure states in real-time. When errors occur, CLI formats error messages with suggestions. He integrates CLI into agent development workflow: validate artifacts, test workflow initiation, verify status checks—all locally. What took 5-10 minutes per iteration via curl now completes in 30 seconds with CLI. He runs 'epf-runtime status wf-abc123' from terminal instead of navigating to web dashboard.
      
      emotional_resolution: |
        Marcus feels productive iterating on agent integrations because CLI provides instant feedback without context switching. He's shifted from "fighting API complexity" to "confidently building workflow automation." His relationship with EPF Runtime has improved—CLI makes API approachable rather than intimidating. He recommends CLI in agent development tutorials, positioning EPF Runtime as developer-friendly platform. The CLI enabled faster prototyping—he tests ideas locally in minutes instead of deploying to staging for hours of feedback. He's become the go-to expert on EPF Runtime CLI patterns, sharing reusable scripts with team.

    - name: "Priya Sharma, DevOps Platform Engineer at CloudScale Systems"
      current_situation: |
        Priya integrates EPF Runtime into CI/CD pipelines for 23 product teams. When integration breaks, she debugs by reading CI logs, finding failed API calls, copying curl commands from logs, running them manually with different parameters, and testing fixes. This requires switching between CI dashboard (logs), terminal (curl), and API docs (endpoint reference). She cannot reproduce CI failures locally—her laptop lacks the exact CI environment (Docker images, credentials, network). Debugging pipeline issues requires 10+ commit/push cycles per fix (change pipeline config → push → wait 5 min → check logs → repeat). Teams wait hours for pipeline fixes while Priya iterates through debugging process.
      
      transformation_moment: |
        With the CLI, Priya reproduces CI workflow issues locally without pushing commits. She configures .epf-runtime.yaml with staging API endpoint and test credentials (separate from production). She runs exact CI workflow steps locally: 'epf-runtime validate artifacts/*.yaml && epf-runtime run ready'. CLI output matches CI log format, allowing direct comparison. When fixing issues, she tests locally first (2 min iteration) instead of pushing to CI (5 min iteration). She creates reusable CLI scripts for common pipeline operations: validate-all.sh, deploy-workflow.sh. CLI's JSON output mode enables scripting: 'epf-runtime status wf-123 --json | jq .status'. What took 10+ CI iterations (hours) now completes in 3-4 local iterations (15 min).
      
      emotional_resolution: |
        Priya feels confident fixing pipeline issues because local testing matches CI behavior. She's shifted from "guessing and hoping CI works" to "verifying locally before pushing." Her relationship with product teams has improved—she debugs issues in minutes instead of hours. She presents CLI integration patterns at DevOps meetups, showcasing rapid pipeline development workflows. The CLI enabled her to create self-service pipeline templates—teams run CLI commands locally to test before requesting pipeline changes. She's freed from being pipeline bottleneck, focusing on platform architecture instead of debugging individual team issues.

    - name: "Alex Rivera, Startup CTO at VentureFlow"
      current_situation: |
        Alex's 6-person startup uses EPF Runtime but lacks dedicated DevOps expertise. Team members are product engineers comfortable with CLI tools (Git, npm, Docker) but not REST APIs. When workflows fail, team Slack messages Alex asking "what's wrong?", he opens browser dashboard, checks workflow status, reads logs, and explains errors via Slack. Team members cannot self-serve debugging because browser dashboard requires navigation through multiple screens. Alex wants team to be self-sufficient with EPF Runtime but API complexity creates dependency on him. Engineers avoid EPF Runtime features because they lack confidence using APIs directly. Manual workflow status checks interrupt Alex 8-12 times per day.
      
      transformation_moment: |
        With the CLI, Alex onboards engineers using familiar tool: 'npm install -g @epf/runtime-cli'. Engineers run 'epf-runtime validate' in their project directories like running 'npm test'—consistent developer experience. When workflows fail, engineers run 'epf-runtime status wf-456' themselves instead of Slack-asking Alex. CLI output is self-explanatory (colored status, clear errors) rather than requiring interpretation. Alex creates bash aliases for common operations: alias epf-test='epf-runtime validate artifacts/*.yaml'. Engineers integrate CLI into git pre-commit hooks, catching issues before commit. What required 8-12 interruptions daily (hours of Alex's time) now happens self-service. Team confidently uses EPF Runtime features because CLI matches their existing tool expectations.
      
      emotional_resolution: |
        Alex feels relieved that team is self-sufficient with EPF Runtime workflows. He's shifted from "being workflow support desk" to "trusting team to debug themselves." His relationship with engineers has improved—they appreciate tooling that matches their workflow instead of forcing context switches. He pitches to investors that small team has "enterprise workflow capabilities with developer-friendly tooling." The CLI enabled faster execution—team doesn't wait for Alex to debug, unblocking product development. He's become advocate for CLI-first developer tools, sharing philosophy in startup CTO communities.

    - name: "Dr. Emily Watson, Product Research Lead at InnovateLabs"
      current_situation: |
        Emily monitors EPF Runtime workflows across 8 projects but lacks terminal/CLI expertise—she's primarily research-focused, not engineering-focused. She checks workflow status via browser dashboard, which requires logging in, navigating to workspace, finding project, and clicking through to workflow details. This multi-step process means she checks status sporadically (once daily) instead of continuously. When workflows fail, she lacks visibility into technical error details—dashboard shows "failed" but not why. She emails project leads asking for status updates, adding latency to issue resolution. She cannot generate reports programmatically—must manually screenshot dashboard status and paste into presentations. Research stakeholders ask "which projects are on track?" but Emily lacks quick way to answer.
      
      transformation_moment: |
        With the CLI, Emily runs 'epf-runtime status --all' in terminal to see status for all 8 projects in single table. CLI's simple output (project name, phase, status, completion %) is easier than navigating 8 browser tabs. Her assistant (less technical) can run CLI commands via documentation: 'Run this command daily, paste output in Slack #research channel.' CLI's --json output enables scripting: engineers create auto-report.sh that generates CSV of workflow statuses for Emily's weekly research review. She runs 'epf-runtime status wf-789 --watch' during project reviews, streaming live status updates while discussing with teams. What required manual dashboard navigation (15 min daily) now completes in 30 seconds via CLI. She embeds CLI output in research reports as evidence of systematic project execution.
      
      emotional_resolution: |
        Emily feels empowered monitoring workflows without requiring engineering assistance. She's shifted from "dependent on engineers for status updates" to "self-service workflow visibility." Her relationship with technical teams has improved—she asks specific questions based on CLI data rather than vague status inquiries. She presents at research conferences about scaling systematic innovation practices using accessible tooling. The CLI enabled data-driven research leadership—she makes decisions based on workflow metrics, not subjective status reports. She's become advocate for "tools that match user expertise" philosophy, influencing tool selection across organization.

  scenarios:
    - id: "scn-012-001"
      name: "Developer Validates Artifact Locally Before Commit"
      actor: "Marcus Chen (developing agent integration)"
      context: "Marcus editing North Star artifact. Before committing, wants to validate locally using CLI instead of waiting for pre-commit hook."
      trigger: "Marcus completes artifact edits and prepares to test validation"
      action: |
        1. Marcus opens terminal in project directory
        2. Runs: 'epf-runtime validate artifacts/north-star.yaml'
        3. CLI reads file, calls validation API with content
        4. API returns validation errors (2 found)
        5. CLI displays errors in terminal with colored formatting:
           ERROR: artifacts/north-star.yaml:45
           Field: definition.success_metrics[1].target
           Issue: Must be string, found number
           Fix: Quote the value: target: "95%"
        6. Marcus fixes errors in editor, saves file
        7. Runs validation again: 'epf-runtime validate artifacts/north-star.yaml'
        8. CLI displays: ✓ Valid (validated against schema v2.0 in 0.3s)
      outcome: |
        Artifact validated locally in 45 seconds total (two iterations). Marcus commits with confidence. Pre-commit hook runs same validation, passes immediately (cached result). Zero CI pipeline failures from validation issues.
      acceptance_criteria:
        - "CLI displays errors with file paths, line numbers, field names, and fix suggestions"
        - "Colored output: errors in red, success in green, info in blue"
        - "Exit code 0 if valid, 1 if errors (enables scripting: epf-runtime validate file.yaml && git commit)"
        - "Performance: validation completes in <1 second for typical artifacts (<100KB)"
        - "Works offline: if API unreachable, falls back to bundled schema validation with warning"

    - id: "scn-012-002"
      name: "DevOps Engineer Tests Pipeline Integration Locally"
      actor: "Priya Sharma (integrating EPF Runtime into CI)"
      context: "Priya writing GitHub Actions workflow that initiates EPF workflows. Wants to test locally before pushing to Git."
      trigger: "Priya completes pipeline script draft and needs to verify it works"
      action: |
        1. Priya creates .epf-runtime.yaml config file: api_url, workspace_id, api_key (test environment)
        2. Runs pipeline script locally: './ci-scripts/epf-workflow.sh'
        3. Script calls: 'epf-runtime run ready --data artifacts/north-star.yaml'
        4. CLI displays: Initiating READY workflow... ✓ Created workflow wf-abc123 (Monitor: http://dashboard.url/wf-abc123)
        5. Priya runs: 'epf-runtime status wf-abc123 --watch'
        6. CLI displays live-updating status table:
           Step                  Status      Time
           Validate Artifacts    Complete    0:12
           Create Tasks          Running     0:08 (current)
           Notify Team           Pending     --
        7. Workflow completes after 2 minutes, CLI shows: ✓ Workflow complete (Duration: 2m 15s)
        8. Priya commits pipeline script with confidence
      outcome: |
        Pipeline tested locally in 3 minutes. Priya verifies workflow initiation, status monitoring, and completion detection work correctly. Pushes to CI. Pipeline runs successfully on first attempt. Zero debugging iterations needed.
      acceptance_criteria:
        - "CLI can read config from .epf-runtime.yaml (committed to Git without secrets)"
        - "Environment variable EPF_RUNTIME_API_KEY overrides config file for CI security"
        - "--watch flag updates status in-place (no scrolling output) with timestamps"
        - "Ctrl+C exits watch mode gracefully without terminating workflow"
        - "JSON output mode: --json flag returns machine-parsable response for scripting"

    - id: "scn-012-003"
      name: "Startup Engineer Self-Serves Workflow Debugging"
      actor: "Junior Engineer (Jamie) on Alex's Team"
      context: "Jamie triggered workflow via button in app. Workflow failed. Jamie needs to understand why without asking Alex."
      trigger: "Slack bot posts notification: 'Workflow wf-def456 failed. Run epf-runtime logs wf-def456 for details.'"
      action: |
        1. Jamie opens terminal (already has CLI installed via team setup script)
        2. Runs: 'epf-runtime logs wf-def456'
        3. CLI displays workflow logs in reverse-chronological order:
           [2024-12-30 14:32:15] ERROR: Artifact validation failed
           [2024-12-30 14:32:14] INFO: Validating roadmap.yaml
           [2024-12-30 14:32:10] INFO: Workflow started by jamie@ventureflow.com
        4. Jamie sees validation failed, runs: 'epf-runtime validate artifacts/roadmap.yaml'
        5. CLI shows: ERROR: roadmap.yaml:78 - OKR 2 missing key_results array
        6. Jamie edits roadmap.yaml, adds key_results, saves
        7. Jamie retries workflow: 'epf-runtime run ready --data artifacts/roadmap.yaml'
        8. CLI displays: ✓ Created workflow wf-ghi789
        9. Jamie runs: 'epf-runtime status wf-ghi789' and sees: Status: Complete ✓
      outcome: |
        Jamie debugged and fixed workflow issue independently in 8 minutes. No Slack interruptions to Alex. Jamie learned workflow debugging pattern through self-service CLI experience. Team velocity maintained.
      acceptance_criteria:
        - "CLI requires minimal configuration: single 'epf-runtime init' command sets up workspace"
        - "Error messages include next-step suggestions: 'Run epf-runtime validate <file> to check artifact'"
        - "Help text accessible via --help flag for every command"
        - "Logs command supports --follow flag for real-time log streaming"
        - "CLI detects common mistakes: 'Did you mean run instead of start?'"

    - id: "scn-012-004"
      name: "Research Lead Generates Status Report via CLI"
      actor: "Dr. Emily Watson (preparing weekly research review)"
      context: "Emily needs workflow status for all 8 projects for Friday stakeholder meeting. Using CLI instead of manual dashboard navigation."
      trigger: "Thursday afternoon: Emily prepares weekly status slides"
      action: |
        1. Emily opens terminal (learned single CLI command via 1-page doc from team)
        2. Runs: 'epf-runtime status --all --workspace research-portfolio'
        3. CLI displays formatted table:
           Project          Phase   Status      Progress   Updated
           Alpha            READY   Complete    100%       2h ago
           Beta             FIRE    Running     67%        5m ago
           Gamma            READY   Failed      45%        1d ago
           ...
        4. Emily copies table, pastes into Slack #research channel
        5. For detailed report, runs: 'epf-runtime status --all --format csv > status-2024-12-30.csv'
        6. Emily opens CSV in Excel, creates pivot table, adds to slide deck
        7. During meeting, stakeholder asks "what's Gamma's error?", Emily runs live:
           'epf-runtime logs proj-gamma-wf-123 --tail 5'
        8. CLI shows last 5 log entries, Emily sees validation error, explains to stakeholder
      outcome: |
        Status report generated in 3 minutes (vs 20 minutes via dashboard). Live CLI demo during meeting shows real-time workflow visibility, impressing stakeholders. Emily confidently discusses project health using CLI data.
      acceptance_criteria:
        - "--all flag lists workflows for all projects in workspace"
        - "--format flag supports: table (default), csv, json for different use cases"
        - "Table output uses Unicode box-drawing characters for readability"
        - "Relative timestamps (2h ago, 1d ago) instead of absolute dates for quick scanning"
        - "Color-coded status: green (complete), yellow (running), red (failed), gray (pending)"

  contexts:
    - id: "ctx-012-001"
      type: "terminal"
      name: "CLI Commands Interface"
      description: |
        Command-line interface providing EPF Runtime operations via terminal commands. Primary interface for developers doing local testing, DevOps engineers scripting CI/CD, and power users preferring keyboard-driven workflows over web dashboards.
      
      key_interactions:
        - "epf-runtime validate <file> - Validate artifact against schema"
        - "epf-runtime run <phase> - Initiate workflow (READY/FIRE/AIM)"
        - "epf-runtime status <workflow-id> - Check workflow progress"
        - "epf-runtime logs <workflow-id> - View workflow execution logs"
        - "epf-runtime config - Manage configuration (.epf-runtime.yaml)"
        - "epf-runtime --help - Show command reference"
        - "All commands support --json flag for machine-parsable output"
      
      data_displayed:
        - "Colored terminal output: errors (red), success (green), info (blue), warnings (yellow)"
        - "Progress bars for long operations (validation, workflow execution)"
        - "Formatted tables with alignment for status listings"
        - "Relative timestamps (2m ago, 5h ago) for recency indication"
        - "Exit codes: 0 (success), 1 (error), 2 (invalid usage) for scripting"
        - "Error messages with line numbers, field paths, and fix suggestions"

    - id: "ctx-012-002"
      type: "file"
      name: "Configuration File (.epf-runtime.yaml)"
      description: |
        YAML configuration file for CLI settings. Stores API endpoint, workspace ID, and optional preferences. Can be committed to Git (without API key) for team sharing. Environment variables override config for CI/CD security.
      
      key_interactions:
        - "Create config: epf-runtime init (interactive prompts for API URL, workspace)"
        - "Edit config: epf-runtime config set api_url https://api.example.com"
        - "View config: epf-runtime config list (shows current settings)"
        - "Environment override: EPF_RUNTIME_API_KEY=secret epf-runtime run ready"
        - "Multiple configs: epf-runtime --config staging.yaml run ready"
      
      data_displayed:
        - "api_url: EPF Runtime API endpoint (https://api.epf-runtime.com)"
        - "workspace_id: Default workspace for operations (workspace-abc-123)"
        - "api_key: Authentication key (store in env var for security, not in file)"
        - "output_format: Default format (table, json, csv)"
        - "color: Enable colored output (true/false, auto-detect terminal support)"

    - id: "ctx-012-003"
      type: "integration"
      name: "CI/CD Pipeline Scripts"
      description: |
        Bash/shell scripts using CLI for automated workflow operations in CI/CD pipelines. Demonstrates CLI integration patterns, error handling, and output parsing for continuous integration.
      
      key_interactions:
        - "Install CLI in CI: npm install -g @epf/runtime-cli"
        - "Configure via env vars: export EPF_RUNTIME_API_KEY=$SECRET_KEY"
        - "Validate all artifacts: epf-runtime validate artifacts/*.yaml || exit 1"
        - "Parse JSON output: STATUS=$(epf-runtime status wf-123 --json | jq -r .status)"
        - "Conditional logic: if [[ $STATUS == 'complete' ]]; then deploy; fi"
        - "Fail fast: set -e ensures pipeline stops on first CLI error"
      
      data_displayed:
        - "CI logs showing CLI output (matches local terminal output)"
        - "Exit codes determining pipeline success/failure"
        - "JSON output parsed via jq for conditional pipeline logic"
        - "Timing information: 'Validated 12 artifacts in 2.3s'"
        - "Summary messages: '✓ All workflows completed successfully'"

    - id: "ctx-012-004"
      type: "documentation"
      name: "CLI Quick Start Guide"
      description: |
        Single-page documentation for CLI installation, configuration, and common commands. Optimized for developers who prefer learning-by-doing over comprehensive manuals. Includes copy-paste examples for frequent operations.
      
      key_interactions:
        - "Installation: npm install -g @epf/runtime-cli"
        - "First-time setup: epf-runtime init (interactive wizard)"
        - "Test connection: epf-runtime status --all (lists workflows)"
        - "Common workflow: validate → run → status → logs"
        - "Get help: epf-runtime <command> --help"
        - "Troubleshooting: epf-runtime doctor (checks config, connectivity)"
      
      data_displayed:
        - "Installation commands for npm, yarn, homebrew"
        - "Configuration examples with placeholders: api_url: YOUR_API_URL"
        - "Copy-paste command examples for common operations"
        - "Expected output samples showing what success looks like"
        - "Troubleshooting table: Error → Cause → Solution"
        - "Links to full API reference for advanced usage"

  dependencies:
    requires:
      - id: "fd-010"
        name: "Workflow Initiation API"
        reason: "CLI 'run' command wraps workflow initiation API endpoint. CLI authenticates requests, constructs payloads, and formats responses from API. Without workflow API, CLI would have no backend to call for workflow operations. CLI makes API accessible to developers preferring command-line tools over direct HTTP requests."
      
      - id: "fd-011"
        name: "EPF Schema Validation Service"
        reason: "CLI 'validate' command calls validation service API with artifact content. CLI formats validation errors in developer-friendly terminal output with syntax highlighting and line numbers. Without validation API, CLI would need to bundle schema validation logic, making it heavyweight and hard to keep synchronized with server-side schemas. API-backed validation ensures CLI uses same validation as workflows and CI pipelines."
    
    enables: []

  boundaries:
    non_goals:
      - "Artifact editing in CLI (users edit in their preferred text editor)"
      - "Interactive TUI (text user interface) with menus and forms (keeps CLI simple and scriptable)"
      - "Artifact generation commands (covered by separate artifact generation tools)"
      - "Workflow cancellation/modification (deferred to Phase 2)"
      - "Multi-workspace management UI (use multiple config files instead)"
      - "Plugin system for custom commands (defer until clear user demand)"
    
    constraints:
      - "Requires Node.js ≥18 (uses modern JS features, native fetch)"
      - "CLI size: <5MB installed (including dependencies)"
      - "Command execution timeout: 30 seconds (for non-watch commands)"
      - "Configuration file format: YAML only (no JSON, TOML alternatives)"
      - "Output width: Respects terminal width (minimum 80 columns required)"
      - "Color support: Auto-detects terminal capabilities, disables colors if unsupported"
      - "Platform support: macOS, Linux, Windows (via WSL or native)"
