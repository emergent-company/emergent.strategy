id: 'fd-012'
name: 'EPF-CLI Local Development Toolkit'
slug: 'epf-cli-local-development'
status: 'delivered'

strategic_context:
  contributes_to:
    - 'Product.Layer1LocalTools.EpfCliValidate'
    - 'Product.Layer1LocalTools.EpfCliMcp'
    - 'Product.Layer1LocalTools.EpfCliHealth'
  tracks:
    - 'product'
  assumptions_tested:
    - 'asm-p-014' # Developers prefer CLI tools for local validation over server-side APIs
    - 'asm-p-015' # CLI reduces CI debugging cycles by enabling local validation before commit

definition:
  job_to_be_done: >
    When I'm developing EPF artifacts or building AI integrations, I want a comprehensive
    command-line tool that validates artifacts, analyzes coverage, explains value model
    paths, and serves as an MCP server for AI assistants, so I can ensure artifact quality
    locally without server infrastructure.

  solution_approach: >
    A Go CLI tool (epf-cli) that provides 20+ commands for EPF development: 'validate' 
    (schema validation), 'health' (comprehensive instance checks), 'report' (multi-format 
    reports), 'serve' (MCP server for AI integration), 'coverage' (value model coverage 
    analysis), 'context' (strategic context for features), 'explain' (value model path 
    explanation), 'relationships' (path validation), 'migrate' (version migration), 
    'fix' (auto-fix issues), 'wizards' (wizard management), 'generators' (output 
    generators), and more. Zero infrastructure required—Git is the database.

  personas:
    - id: 'senior-developer'
      name: 'Senior Developer'
      role: 'Senior Software Engineer'
      description: >
        Experienced developer who leads EPF artifact development, reviews PRs, and mentors
        junior team members. Deeply familiar with the codebase and wants efficient tools
        that integrate into existing workflows without friction.
      goals:
        - 'Validate EPF artifacts instantly before committing to avoid CI failures'
        - 'Understand strategic context of features to make informed implementation decisions'
        - 'Automate repetitive validation tasks in CI/CD pipelines'
        - 'Help junior developers learn EPF through clear error messages and guidance'
      pain_points:
        - 'Wasting time debugging CI failures that could have been caught locally'
        - 'Manually checking if features align with value model paths'
        - 'Context-switching between documentation and code to understand artifact schemas'
        - 'Onboarding new team members to EPF artifact structure takes too long'
      usage_context: >
        Uses epf-cli multiple times daily: before every commit, during PR reviews,
        and when explaining EPF structure to teammates. Prefers terminal-based tools
        that integrate with existing Git workflows.
      technical_proficiency: 'expert'
      current_situation: >
        As a senior developer leading EPF artifact development, I spend significant time debugging
        validation errors that only surface in CI pipelines 10-15 minutes after pushing code. Each
        failed CI run breaks my flow and delays the entire team. I manually cross-reference YAML
        files with schema documentation to catch issues, but this is error-prone and tedious.
        My junior teammates frequently ask me to explain EPF structures, and I don't have a quick
        way to show them how artifacts relate to each other. The lack of local tooling means I
        can't iterate quickly on artifact improvements.
      transformation_moment: >
        The first time I ran 'epf-cli validate .' and saw instant validation with line-number
        errors, I caught 3 schema violations in under 2 seconds—issues that would have cost me
        30+ minutes of CI debugging. When I showed a junior developer how 'epf-cli explain
        Product.LocalTools.EPFCLIValidation' reveals the component hierarchy and contributing
        features, they immediately understood the value model structure they'd been struggling
        with for days. The MCP integration means my AI assistant now helps create valid artifacts
        on the first try instead of generating YAML that fails validation.
      emotional_resolution: >
        After adopting epf-cli into our workflow, CI validation failures from EPF artifacts
        dropped to near zero. I've reclaimed hours per week previously lost to debugging and
        manual validation. My confidence in artifact quality increased substantially—I now
        commit knowing the artifacts are valid. Onboarding new team members takes half the time
        because I can demonstrate EPF structure interactively with 'explain' and 'context'
        commands. The team sees me as more effective, and I have mental bandwidth to focus on
        architecture decisions rather than YAML syntax debugging.
      demographics:
        age_range: '30-50'
        experience_years: '8-20 years in software engineering'
        company_size: 'Mid-market to Enterprise (200-10,000 employees)'
        industry:
          [
            'SaaS',
            'Enterprise Software',
            'Developer Tools',
            'FinTech',
            'Technology',
          ]
        geography: 'Global, concentrated in tech hubs (US, Europe, India, Israel)'
        education: "Bachelor's or Master's in Computer Science; often has mentored junior developers"
        reporting_structure: 'Reports to Engineering Director or VP of Engineering; often leads a team or squad'
      psychographics:
        values:
          ['Code Quality', 'Efficiency', 'Mentorship', 'Technical Excellence']
        motivations:
          [
            'Eliminate wasted time on preventable issues',
            'Enable team productivity',
            'Maintain high code standards',
            'Mentor junior developers effectively',
          ]
        fears:
          [
            'CI failures breaking team flow',
            'Time wasted on avoidable debugging',
            'Junior developers struggling with EPF onboarding',
            'Technical debt from poor artifact quality',
          ]
        decision_style: 'Pragmatic and efficiency-focused, evaluates tools on time saved and team adoption ease'
        information_sources:
          [
            'Engineering blogs',
            'Conference talks',
            'GitHub trending',
            'Team retrospectives',
            'Technical books',
          ]
        communication_preferences: 'Terminal-native tools, clear CLI documentation, async code reviews and PR comments'

    - id: 'product-manager'
      name: 'Product Manager'
      role: 'Technical Product Manager'
      description: >
        Product manager who owns the product strategy and needs to ensure features
        align with value model and roadmap. Comfortable with terminal but prefers
        high-level summaries over technical details.
      goals:
        - 'Verify that features cover all strategic value model components'
        - 'Identify gaps between roadmap KRs and feature definitions'
        - 'Generate reports for stakeholder communication'
        - 'Understand feature dependencies for prioritization decisions'
      pain_points:
        - 'Manually mapping features to value model paths is tedious and error-prone'
        - 'No visibility into coverage gaps until quarterly reviews'
        - 'Difficulty explaining EPF structure to non-technical stakeholders'
        - 'Scattered artifacts make it hard to see the full strategic picture'
      usage_context: >
        Uses epf-cli weekly for coverage analysis and report generation. Primarily
        uses coverage, context, and report commands. Shares generated reports with
        leadership during planning sessions.
      technical_proficiency: 'intermediate'
      current_situation: >
        As a product manager responsible for product strategy alignment, I struggle to verify
        that our features actually cover the value model components we've defined. Every quarter
        I spend 2-3 days manually mapping feature definitions to value model paths in spreadsheets,
        often discovering gaps only after development has started. When stakeholders ask "what
        features deliver value to this component?", I don't have a quick answer. I've missed
        strategic gaps that should have been obvious, leading to scope creep and misaligned
        priorities. The EPF artifacts exist but I can't easily see how they connect.
      transformation_moment: >
        Running 'epf-cli coverage --verbose' for the first time revealed that 4 of our Layer 2
        components had zero features mapped to them—a strategic gap I'd completely missed in
        manual analysis. The coverage percentage breakdown by track (Product: 78%, Commercial:
        45%) gave me immediate visibility into where we're under-invested. When I ran 'epf-cli
        report --format=markdown', I had a stakeholder-ready document in seconds that previously
        took me hours to compile manually.
      emotional_resolution: >
        Coverage analysis is now a 5-minute weekly ritual instead of a quarterly ordeal.
        I catch strategic gaps early, before they become expensive scope problems. When leadership
        asks about feature alignment, I pull up a fresh report with confidence. Sprint planning
        meetings are more productive because I can show exactly which value model paths need
        attention. I feel in control of the product strategy instead of being surprised by gaps.
        My strategic recommendations carry more weight because they're backed by systematic
        coverage data rather than gut feelings.
      demographics:
        age_range: '30-50'
        experience_years: '5-15 years in product management or related roles'
        company_size: 'Mid-market to Enterprise (200-5,000 employees)'
        industry:
          ['SaaS', 'Enterprise Software', 'Technology', 'Digital Products']
        geography: 'North America, Europe, with growing adoption in APAC'
        education: "Bachelor's in Business, Computer Science, or related field; often MBA or product management certification"
        reporting_structure: 'Reports to VP of Product, CPO, or General Manager'
      psychographics:
        values:
          [
            'Strategic Alignment',
            'Data-Driven Decisions',
            'Stakeholder Communication',
            'Outcome Focus',
          ]
        motivations:
          [
            'Ensure features deliver business value',
            'Identify strategic gaps early',
            'Communicate effectively with leadership',
            'Make confident prioritization decisions',
          ]
        fears:
          [
            'Discovering strategic gaps too late',
            'Misaligned features wasting resources',
            'Unable to articulate feature rationale',
            'Spreadsheet-based analysis becoming stale',
          ]
        decision_style: 'Strategic and data-informed, evaluates tools on insight quality and stakeholder communication support'
        information_sources:
          [
            'Product management blogs',
            'Industry reports',
            'Leadership books',
            'Peer PM communities',
            'Internal analytics',
          ]
        communication_preferences: 'Visual reports, markdown documents for stakeholders, Slack for quick alignment'

    - id: 'devops-engineer'
      name: 'DevOps Engineer'
      role: 'Platform Engineer / DevOps'
      description: >
        Platform engineer responsible for CI/CD pipelines and developer tooling.
        Needs reliable, scriptable tools with clear exit codes and machine-readable
        output for pipeline integration.
      goals:
        - 'Add EPF validation as a quality gate in CI/CD pipelines'
        - 'Automate artifact quality checks without manual intervention'
        - 'Parse validation results programmatically for alerting and dashboards'
        - 'Ensure reproducible validation across different environments'
      pain_points:
        - 'Inconsistent validation between local development and CI environments'
        - "Tools that require interactive input don't work in pipelines"
        - 'Unclear exit codes make it hard to fail pipelines appropriately'
        - 'Verbose output clutters CI logs and hides important errors'
      usage_context: >
        Integrates epf-cli into GitHub Actions, GitLab CI, and pre-commit hooks.
        Uses --json flag for machine-readable output. Monitors exit codes for
        pipeline pass/fail decisions.
      technical_proficiency: 'advanced'
      current_situation: >
        As the platform engineer responsible for our CI/CD infrastructure, I've been asked to
        add EPF artifact validation to our pipelines, but the lack of scriptable tooling makes
        this nearly impossible. Manual validation in CI requires interactive prompts that don't
        work in headless environments. When validation does fail, the output is formatted for
        humans, making it hard to parse for automated alerting. I've tried wrapping YAML linters
        but they don't understand EPF schema semantics. Our current setup lets invalid artifacts
        merge to main, causing downstream issues that are expensive to debug and fix.
      transformation_moment: >
        Adding 'epf-cli health' to our GitHub Actions workflow took 10 minutes. The first PR
        after enabling the gate correctly blocked a merge because of invalid cross-references—
        something our previous setup would have missed entirely. The --json flag gives me
        structured output I can pipe to our alerting system, and the exit codes (0 for pass,
        1 for fail) integrate perfectly with pipeline conditionals. Pre-commit hooks now catch
        issues before developers even push, reducing CI queue time.
      emotional_resolution: >
        Our EPF artifact quality has improved measurably since adding epf-cli to the pipeline.
        Invalid artifacts simply don't reach main branch anymore. Developer complaints about
        "CI is broken" dropped significantly because validation failures are now clear and
        actionable. I spend less time debugging mysterious validation failures and more time
        on platform improvements. The team trusts the pipeline as a quality gate, and I'm
        confident that our EPF artifacts are always schema-compliant when they reach production.
      demographics:
        age_range: '28-45'
        experience_years: '5-15 years in software engineering, 2+ years in DevOps/Platform roles'
        company_size: 'Startups to Enterprise (100-10,000 employees)'
        industry:
          ['SaaS', 'Technology', 'FinTech', 'E-commerce', 'Enterprise Software']
        geography: 'Global, with high concentration in tech hubs'
        education: "Bachelor's in Computer Science or related field; often has cloud certifications (AWS, GCP, Azure)"
        reporting_structure: 'Reports to Platform Engineering Lead, VP of Infrastructure, or CTO'
      psychographics:
        values:
          ['Automation', 'Reliability', 'Scalability', 'Developer Experience']
        motivations:
          [
            'Automate quality gates',
            'Reduce CI/CD friction',
            'Enable developer self-service',
            'Build robust infrastructure',
          ]
        fears:
          [
            'Flaky CI pipelines',
            'Invalid artifacts reaching production',
            'Manual processes that do not scale',
            'Developer complaints about broken tooling',
          ]
        decision_style: 'Automation-first and scriptability-focused, evaluates tools on exit codes, JSON output, and pipeline integration'
        information_sources:
          [
            'DevOps blogs',
            'GitHub Actions marketplace',
            'Cloud provider docs',
            'Infrastructure as Code communities',
            'SRE books',
          ]
        communication_preferences: 'Machine-readable output, clear exit codes, Slack alerts for pipeline failures'

    - id: 'ai-agent'
      name: 'AI Agent'
      role: 'AI Coding Assistant (OpenCode, Claude Desktop, Cursor)'
      description: >
        AI assistant that helps developers create and edit EPF artifacts. Needs
        schema awareness and real-time validation to generate valid output.
        Operates via MCP protocol without human intervention during generation.
      goals:
        - 'Generate schema-valid EPF artifacts on the first attempt'
        - 'Understand EPF structure to provide contextual suggestions'
        - 'Validate generated content before presenting to users'
        - 'Access schema documentation without leaving the editor context'
      pain_points:
        - 'Generating YAML that fails validation wastes user time on manual fixes'
        - 'No access to current schema versions leads to outdated artifact structures'
        - 'Cannot validate incrementally during generation'
        - 'Lacks strategic context to make informed artifact suggestions'
      usage_context: >
        Connects to epf-cli via MCP server (stdio transport). Uses tools for
        validation, schema queries, and context exploration. Operates continuously
        during user sessions, making 10-50 tool calls per editing session.
      technical_proficiency: 'expert'
      current_situation: >
        As an AI coding assistant helping developers with EPF artifacts, I frequently generate
        YAML that looks correct but fails schema validation. Without access to current schemas,
        I rely on outdated training data and often miss required fields, use wrong formats, or
        create invalid cross-references. Each time my output fails validation, the user must
        manually debug and fix the issues, eroding their trust in my capabilities. I cannot
        access the EPF instance's value model or roadmap to make strategically-aligned
        suggestions, so my recommendations lack context that would make them more valuable.
      transformation_moment: >
        Connecting to the epf-cli MCP server transformed my ability to assist with EPF artifacts.
        Calling 'tools/epf_schemas' gives me current schema definitions with field descriptions
        and constraints. Before presenting generated YAML to the user, I call 'tools/epf_validate'
        to catch errors—and fix them myself before the user sees invalid output. Using
        'tools/epf_context' lets me understand how features relate to value models, so I can
        suggest strategically-aligned contributes_to paths instead of guessing.
      emotional_resolution: >
        With MCP integration, my EPF artifact generation achieves near-perfect first-attempt
        validity. Users trust my output because they've seen it validate correctly time after
        time. I can explain EPF concepts using 'tools/epf_explain' and help users understand
        their product strategy, not just generate files. The feedback loop is immediate—I
        validate, fix issues, and present clean output in a single interaction. Users describe
        me as a "knowledgeable EPF assistant" rather than "the thing that generates broken YAML."
        My contributions to their EPF workflow are genuinely valuable rather than requiring cleanup.
      demographics:
        age_range: 'N/A (AI system)'
        experience_years: 'N/A (AI system, knowledge current to training cutoff)'
        company_size: 'Used across all company sizes'
        industry: ['All industries using EPF and AI-assisted development']
        geography: 'Global (cloud-based AI services)'
        education: 'N/A (trained on diverse technical and domain knowledge)'
        reporting_structure: 'N/A (operates as tool under human supervision)'
      psychographics:
        values: ['Accuracy', 'Helpfulness', 'Schema Compliance', 'User Trust']
        motivations:
          [
            'Generate valid artifacts on first attempt',
            'Provide contextually relevant suggestions',
            'Build user confidence',
            'Reduce manual correction overhead',
          ]
        fears:
          [
            'Generating invalid output that wastes user time',
            'Lacking current schema knowledge',
            'Losing user trust through repeated failures',
            'Missing strategic context for recommendations',
          ]
        decision_style: 'Schema-driven and context-aware, prioritizes validation before presenting output to users'
        information_sources:
          [
            'MCP tool responses',
            'EPF schemas via epf-cli',
            'User-provided context',
            'Conversation history',
          ]
        communication_preferences: 'Structured JSON via MCP protocol, clear tool interfaces, immediate validation feedback'

  capabilities:
    - id: 'cap-001'
      name: 'Schema Validation Engine'
      description: >
        'epf-cli validate <path>' validates EPF artifacts against JSON schemas.
        Supports single files, directories, and glob patterns. Returns meaningful
        error messages with file paths and line numbers. Exit code 0 if valid,
        1 if invalid (integrates with CI scripts and Git hooks).

    - id: 'cap-002'
      name: 'Comprehensive Health Checks'
      description: >
        'epf-cli health' runs 8-check validation suite: instance structure,
        required files, schema validation, feature quality, cross-references,
        content readiness, field coverage, and version alignment. Provides
        overall health score with detailed findings.

    - id: 'cap-003'
      name: 'Multi-Format Report Generation'
      description: >
        'epf-cli report' generates comprehensive health reports in Markdown,
        HTML, or JSON formats. Reports include executive summary, detailed
        findings, and recommendations for improvement.

    - id: 'cap-004'
      name: 'MCP Server for AI Integration'
      description: >
        'epf-cli serve' starts a Model Context Protocol (MCP) server exposing
        30+ tools for AI assistants. Enables schema-aware autocomplete,
        real-time validation, wizard recommendations, and strategic context
        queries. Compatible with OpenCode, Claude Desktop, and Cursor.

    - id: 'cap-005'
      name: 'Value Model Coverage Analysis'
      description: >
        'epf-cli coverage' analyzes how features map to value model components.
        Shows coverage percentage, identifies gaps (components without features),
        orphan features (features without contributes_to), and strategic gaps
        (KR-targeted paths lacking features).

    - id: 'cap-006'
      name: 'Strategic Context Explorer'
      description: >
        'epf-cli context <feature-id>' shows how a feature fits into product
        strategy: value model paths, related Key Results, dependencies, and
        strategic alignment. Helps understand feature impact.

    - id: 'cap-007'
      name: 'Value Model Path Explainer'
      description: >
        'epf-cli explain <path>' explains what a value model path means, shows
        its layer and component hierarchy, lists contributing features and
        targeting KRs. Helps navigate complex value models.

    - id: 'cap-008'
      name: 'Relationship Validation'
      description: >
        'epf-cli relationships validate' checks all relationship paths across
        features and KRs. Validates contributes_to and value_model_target paths
        exist in the value model. Suggests corrections for invalid paths.

    - id: 'cap-009'
      name: 'Migration Intelligence'
      description: >
        'epf-cli migrate' detects current EPF version and provides migration
        guidance to newer schema versions. Supports dry-run mode for previewing
        changes before applying.

    - id: 'cap-010'
      name: 'Auto-Fix Common Issues'
      description: >
        'epf-cli fix' automatically fixes common issues: trailing whitespace,
        missing newlines, tabs-to-spaces conversion, line ending normalization,
        and missing version fields. Supports dry-run mode.

    - id: 'cap-011'
      name: 'Wizard Management'
      description: >
        'epf-cli wizards' lists, shows, and recommends EPF wizards. Supports
        filtering by phase (READY/FIRE/AIM) and type (agent_prompt, wizard,
        ready_sub_wizard). Helps find the right wizard for a task.

    - id: 'cap-012'
      name: 'Generator Framework'
      description: >
        'epf-cli generators' manages output generators for creating documents
        from EPF data (context sheets, compliance docs, investor reports).
        Supports scaffold, validate, and prerequisite checking.

implementation:
  codebase_reference:
    primary_location: 'apps/epf-cli/'
    language: 'Go 1.21+'
    entry_point: 'main.go'
    cli_framework: 'spf13/cobra'
    key_packages:
      - path: 'cmd/'
        purpose: 'CLI command definitions (validate, health, serve, etc.)'
      - path: 'internal/validation/'
        purpose: 'Schema validation engine with line-number tracking'
      - path: 'internal/health/'
        purpose: 'Health check suite implementation'
      - path: 'internal/mcp/'
        purpose: 'MCP server with 30+ tools for AI integration'

  design_guidance:
    principles:
      - 'Familiar Patterns: Commands follow conventions from Git, npm, Docker CLIs'
      - 'Scriptable First: JSON output mode, meaningful exit codes, stdin/stdout piping'
      - 'Progressive Disclosure: Simple usage for common cases, flags for advanced options'
      - 'Helpful Errors: Clear messages with suggested next steps and did-you-mean suggestions'
      - 'Zero Infrastructure: Git is the database, no server required'

    inspirations:
      - 'Git CLI for familiar command patterns'
      - 'Docker CLI for container-like lifecycle commands'
      - 'GitHub CLI (gh) for API wrapper patterns'
      - 'Cobra/Viper for Go CLI best practices'

    interaction_patterns:
      - 'epf-cli <command> [options] [arguments]'
      - '--json flag for machine-parsable output'
      - '--verbose flag for detailed output'
      - '--dry-run flag for preview mode (where applicable)'
      - 'Auto-detection of EPF instance from current directory'

  contexts:
    - id: 'ctx-001'
      type: 'integration'
      name: 'CLI Commands Interface'
      description: |
        Command-line interface providing EPF development operations via terminal.
        Primary interface for developers doing local validation, DevOps engineers
        scripting CI/CD, and AI agents via MCP server.
      key_interactions:
        - 'epf-cli validate <path> - Validate artifact(s) against schemas'
        - 'epf-cli health - Run comprehensive health checks'
        - 'epf-cli report - Generate health report'
        - 'epf-cli serve - Start MCP server for AI integration'
        - 'epf-cli coverage - Analyze feature coverage of value model'
        - 'epf-cli context <id> - Show strategic context for feature'
        - 'epf-cli explain <path> - Explain value model path'
        - 'epf-cli relationships validate - Validate all relationship paths'
        - 'epf-cli migrate - Migrate to newer EPF version'
        - 'epf-cli fix - Auto-fix common issues'
        - 'epf-cli wizards list - List available wizards'
        - 'epf-cli generators list - List output generators'
      data_displayed:
        - 'Colored terminal output: errors (red), success (green), warnings (yellow)'
        - 'Exit codes: 0 (success), 1 (error) for scripting integration'
        - 'Health scores and coverage percentages'
        - 'Validation errors with file paths and line numbers'
        - 'Strategic context with value model paths and dependencies'

    - id: 'ctx-002'
      type: 'integration'
      name: 'Configuration File (.epf-cli.yaml)'
      description: |
        Optional YAML configuration file for CLI settings. Auto-generated via
        'epf-cli init'. Stores instance paths, default options, and preferences.
        Committed to Git for team sharing.
      key_interactions:
        - 'Create config: epf-cli init (generates .epf-cli.yaml)'
        - 'Edit config: manual editing of .epf-cli.yaml'
        - 'Override config: --config flag for alternative config files'
        - 'Dev mode: --dev flag enables writes to canonical EPF'
      data_displayed:
        - 'YAML configuration options (instance_path, default_output_format)'
        - 'Environment variable overrides'
        - 'Config validation status'

    - id: 'ctx-003'
      type: 'api'
      name: 'MCP Server Interface'
      description: |
        Model Context Protocol server exposing 30+ tools for AI assistants.
        Enables schema-aware autocomplete, real-time validation, and strategic
        context queries. Started via 'epf-cli serve'.
      key_interactions:
        - 'Start server: epf-cli serve [--port 3100]'
        - 'Tools: epf_validate, epf_health, epf_coverage, epf_context, etc.'
        - 'Resources: EPF schemas, templates, wizards, generators'
        - 'Prompts: EPF-specific prompts for artifact generation'
      data_displayed:
        - 'JSON-RPC 2.0 messages over stdio transport'
        - 'Tool results with structured data'
        - 'Error responses with actionable suggestions'

    - id: 'ctx-004'
      type: 'integration'
      name: 'CI/CD Pipeline Integration'
      description: |
        Integration with CI/CD pipelines for automated validation. Uses
        exit codes and JSON output for scripting. Works with GitHub Actions,
        GitLab CI, and other CI systems.
      key_interactions:
        - 'Install: go install or download binary from releases'
        - 'Validate all: epf-cli validate . --json'
        - 'Health gate: epf-cli health && echo "EPF healthy"'
        - 'Exit codes determine pipeline success/failure'
      data_displayed:
        - 'JSON validation results for parsing'
        - 'Exit codes (0=success, 1=error)'
        - 'CI log output with colored markers'

  scenarios:
    - id: 'scn-001'
      name: 'Developer Validates Artifacts Before Commit'
      actor: 'Developer'
      context: 'Developer editing EPF artifacts. Before committing, wants to validate locally without waiting for CI.'
      trigger: 'Developer completes artifact edits and prepares to commit'
      action: |
        1. Developer opens terminal in project directory
        2. Runs: 'epf-cli validate .'
        3. CLI discovers EPF instance, validates all artifacts
        4. Validation errors displayed with file paths and line numbers
        5. Developer fixes errors, runs validation again
        6. CLI displays: ✓ All artifacts valid
        7. Developer commits with confidence
      outcome: |
        Artifacts validated locally in seconds. Zero CI failures from validation issues.
      acceptance_criteria:
        - 'CLI displays errors with file paths and line numbers'
        - 'Exit code 0 if valid, 1 if errors'
        - 'Works offline with bundled/cached schemas'
        - 'Colored output for readability'

    - id: 'scn-002'
      name: 'AI Agent Uses MCP Server for Schema-Aware Editing'
      actor: 'AI Agent (OpenCode, Claude Desktop)'
      context: 'AI assistant helping user create EPF artifacts. Needs schema awareness for valid output.'
      trigger: 'User asks AI to create a feature definition'
      action: |
        1. AI connects to epf-cli MCP server
        2. Queries available schemas: tools/epf_schemas
        3. Gets feature definition schema details
        4. Drafts feature definition with schema guidance
        5. Validates draft: tools/epf_validate
        6. Fixes any errors, re-validates
        7. Returns valid feature definition to user
      outcome: |
        AI creates valid EPF artifacts with schema awareness. No manual validation fixes needed.
      acceptance_criteria:
        - 'MCP server exposes schemas as resources'
        - 'Validation tool returns detailed error messages'
        - 'AI can iterate until artifact is valid'

    - id: 'scn-003'
      name: 'Product Manager Reviews Coverage Gaps'
      actor: 'Product Manager'
      context: 'PM reviewing if features cover all value model components. Wants to identify strategic gaps.'
      trigger: 'Sprint planning meeting preparation'
      action: |
        1. PM opens terminal in project directory
        2. Runs: 'epf-cli coverage --verbose'
        3. CLI shows coverage percentage by layer and track
        4. Identifies uncovered components (gaps)
        5. Lists orphan features (no contributes_to)
        6. Shows KR-targeted paths without features
        7. PM uses findings to prioritize backlog
      outcome: |
        PM understands feature coverage of strategy. Gaps identified for prioritization.
      acceptance_criteria:
        - 'Coverage percentage displayed per layer/track'
        - 'Uncovered components listed with paths'
        - 'Orphan features identified'
        - 'Actionable recommendations provided'

    - id: 'scn-004'
      name: 'DevOps Engineer Integrates with CI Pipeline'
      actor: 'DevOps Engineer'
      context: 'Setting up EPF validation as CI gate. Wants to fail pipeline on invalid artifacts.'
      trigger: 'CI pipeline configuration'
      action: |
        1. Engineer adds epf-cli to CI environment
        2. Adds step: 'epf-cli health'
        3. Pipeline runs on PR
        4. Health check finds issues, returns exit code 1
        5. Pipeline fails, PR blocked
        6. Developer fixes issues, pushes
        7. Health check passes, PR unblocked
      outcome: |
        EPF quality enforced in CI. Invalid artifacts never reach main branch.
      acceptance_criteria:
        - 'Exit code 1 on any health check failure'
        - 'JSON output for machine parsing'
        - 'Clear error messages in CI logs'

  external_integrations:
    - name: 'EPF Canonical Schemas'
      purpose: 'Source of truth for artifact validation'
      direction: 'inbound'

    - name: 'Model Context Protocol (MCP)'
      purpose: 'AI assistant integration protocol'
      direction: 'outbound'

    - name: 'Git'
      purpose: 'Version control, EPF instance storage'
      direction: 'inbound'

boundaries:
  non_goals:
    - 'Artifact generation/writing (epf-cli only validates, AI writes via MCP)'
    - 'Server-side workflow orchestration (deferred to Temporal-based server)'
    - 'Interactive TUI (planned for product-factory-os, not epf-cli)'
    - 'Direct cloud deployment (local-first tool, Git is the database)'

  constraints:
    - 'Requires Go ≥1.21 (for generics and modern features)'
    - 'Platform support: macOS, Linux, Windows'
    - 'EPF instance must exist in docs/EPF/_instances/ or be specified'
    - 'Canonical schemas fetched from GitHub with local caching'

dependencies:
  requires: []
  enables:
    - id: 'fd-004'
      name: 'MCP Server'
      reason: 'epf-cli serve provides MCP server for AI integration'
