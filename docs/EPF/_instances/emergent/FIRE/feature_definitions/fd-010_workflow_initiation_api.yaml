id: 'fd-010'
name: 'Workflow Initiation API'
slug: 'workflow-initiation-api'
status: 'draft'

strategic_context:
  contributes_to:
    - 'Product.Layer2WorkflowEngine.DurableExecution.PhaseOrchestration'
  tracks:
    - 'product'
  assumptions_tested:
    - 'asm-p-010' # AI agents and DevOps pipelines can reliably trigger EPF cycles via simple REST API
    - 'asm-p-011' # Teams prefer programmatic workflow initiation over manual YAML editing

definition:
  job_to_be_done: >
    When I'm building an AI agent or DevOps pipeline that needs to start an EPF planning cycle, I want a simple REST API endpoint that accepts workflow parameters and returns a workflow ID, so I can trigger READY/FIRE/AIM phases programmatically without manual YAML file manipulation.

  solution_approach: >
    A RESTful API endpoint that accepts workflow initiation requests with minimal required parameters (phase type, workspace ID, optional pre-filled data). The API validates the request, creates a Temporal workflow, and immediately returns a workflow ID for monitoring. It handles authentication via API keys, supports idempotency for reliable retries, and provides clear error messages when validation fails. Think "Stripe API for EPF workflows" - simple, predictable, well-documented.

  personas:
    - id: 'ai-autonomy-engineer'
      name: 'AI Autonomy Engineer'
      role: 'AI Systems Engineer'
      description: >
        Engineer building autonomous AI agents that orchestrate EPF workflows
        without human intervention. Needs reliable API for triggering workflows
        programmatically with structured inputs and predictable responses.
      goals:
        - 'Trigger EPF workflows from AI agents without manual intervention'
        - 'Pass context from AI analysis to workflow initiation parameters'
        - 'Monitor workflow status programmatically for agent decision-making'
        - 'Handle API errors gracefully with automatic retry logic'
      pain_points:
        - 'Manual workflow initiation bottlenecks autonomous agent capabilities'
        - 'No way to pre-populate artifacts from AI-generated analysis'
        - 'API inconsistencies make error handling unpredictable'
        - 'Rate limits interrupt agent workflows without clear recovery paths'
      usage_context: >
        Builds AI agents that analyze market data and trigger READY phases
        with pre-populated strategic context. Agents monitor workflow progress
        and provide input during FIRE phases. High-frequency API usage.
      technical_proficiency: 'expert'
      current_situation: >
        As an AI systems engineer building autonomous planning agents, I need to trigger EPF
        workflows programmatically when my agents detect strategic opportunities. Currently,
        workflow initiation requires manual YAML file creation and dashboard interaction,
        creating a human bottleneck that defeats the purpose of autonomous agents. My agents
        can analyze market data and generate strategic insights, but they cannot act on those
        insights by starting EPF cycles. I have tried scripting YAML file creation, but the
        workflow system does not pick them up reliably, and error feedback is nonexistent.
        My agents are limited to generating recommendations that humans must manually execute.
      transformation_moment: >
        The workflow initiation API transformed my agents from advisors to autonomous actors.
        My first agent detected a market opportunity, called POST /api/workflows with phase_type
        "READY" and initial_data containing its strategic analysis, and received a workflow_id
        in 200ms. The agent then monitored GET /api/workflows/{id}/status to track progress
        and provided input when the workflow requested it. No human intervention was required
        from opportunity detection to READY phase completion. Idempotency keys prevented
        duplicate workflows when my agent's retry logic fired on network hiccups.
      emotional_resolution: >
        My autonomous agents now participate fully in EPF workflows. They detect opportunities,
        initiate planning cycles, provide input, and monitor outcomes - all programmatically.
        I spend engineering time on agent intelligence rather than workaround scripts for
        manual workflow initiation. The API's predictable error handling makes my agents
        robust to transient failures. Stakeholders see AI agents as strategic partners,
        not just recommendation engines. I am building genuinely autonomous systems that
        execute strategy, not just suggest it.
      demographics:
        age_range: '26-42'
        experience_years: '4-15 years in software engineering, 2+ years in AI/ML systems'
        company_size: 'Startups to Enterprise (50-10,000 employees)'
        industry: ['AI/ML', 'Technology', 'Automation', 'Enterprise Software']
        geography: 'Global, concentrated in AI/tech hubs'
        education: "Bachelor's or Master's in Computer Science, often with AI/ML specialization"
        reporting_structure: 'Reports to Head of AI, VP of Engineering, or CTO'
      psychographics:
        values: ['Autonomy', 'Scalability', 'Reliability', 'Innovation']
        motivations:
          [
            'Build truly autonomous systems',
            'Eliminate human bottlenecks',
            'Create AI that takes action',
            'Pioneer new capabilities',
          ]
        fears:
          [
            'Agents limited by manual processes',
            'Unreliable APIs',
            'Systems that require human intervention',
            'Being constrained by platform limitations',
          ]
        decision_style: 'Experimental and capability-focused, evaluates platforms on API completeness and reliability'
        information_sources:
          [
            'AI research papers',
            'API documentation',
            'Technical blogs',
            'Open source projects',
            'AI engineering communities',
          ]
        communication_preferences: 'Technical documentation, code examples, async communication via GitHub issues'

    - id: 'devops-pipeline-engineer'
      name: 'DevOps Pipeline Engineer'
      role: 'CI/CD Pipeline Engineer'
      description: >
        Engineer building CI/CD pipelines that trigger EPF workflows based on
        code events or scheduled triggers. Needs simple, reliable API that
        integrates with GitHub Actions, GitLab CI, and other CI systems.
      goals:
        - 'Trigger EPF workflows from GitHub Actions on specific events'
        - 'Schedule recurring READY phase initiations for quarterly planning'
        - 'Pass build metadata to workflows for traceability'
        - 'Fail pipelines gracefully when workflow initiation fails'
      pain_points:
        - 'No programmatic way to connect code events to EPF workflow triggers'
        - 'Manual workflow initiation breaks DevOps automation philosophy'
        - 'Cannot pass CI context (commit hash, branch, triggered event) to workflows'
        - 'API errors surface in CI logs without actionable context'
      usage_context: >
        Configures GitHub Actions workflows that call the API on PR merges
        or scheduled triggers. Uses API keys stored in CI secrets. Monitors
        workflow initiation success as pipeline step pass/fail criteria.
      technical_proficiency: 'advanced'
      current_situation: >
        As a pipeline engineer responsible for DevOps automation, I want to connect code
        lifecycle events to EPF workflows - trigger READY phases when major releases ship,
        start FIRE phases when feature branches merge. But workflow initiation is entirely
        manual, disconnecting product planning from the development process it governs.
        I have tried webhook-based workarounds, but they are brittle and lack proper
        authentication. When workflows do start manually, there is no traceability back to
        the code event that should have triggered them. My CI/CD pipelines are comprehensive
        for code, but EPF workflows exist in a parallel manual universe.
      transformation_moment: >
        Integrating the workflow API into GitHub Actions took one afternoon. On PR merge to
        main, my pipeline now calls POST /api/workflows with phase_type "AIM" and metadata
        including commit SHA and merged features. The API returns workflow_id which I log
        for traceability. Failed workflow initiation fails the pipeline with clear error
        messages from the API. Scheduled triggers run quarterly READY phases automatically.
        EPF workflows are now part of the development lifecycle, not separate from it.
      emotional_resolution: >
        Our product planning is now integrated with our development process. Code events
        trigger appropriate EPF workflows automatically, creating a connected system where
        strategy informs development and development outcomes feed back to strategy.
        I spend less time on manual workflow coordination and more on pipeline improvements.
        Leadership appreciates the traceability from code to strategy to code. DevOps
        principles now apply to product planning, not just software delivery.
      demographics:
        age_range: '27-45'
        experience_years: '5-15 years in DevOps, SRE, or platform engineering'
        company_size: 'Growth-stage to Enterprise (100-10,000 employees)'
        industry: ['Technology', 'SaaS', 'Financial Services', 'E-commerce']
        geography: 'Tech-forward organizations with mature CI/CD practices'
        education: "Bachelor's in Computer Science or related field; DevOps certifications common"
        reporting_structure: 'Reports to Director of Platform Engineering, VP of Infrastructure, or CTO'
      psychographics:
        values:
          ['Automation', 'Reliability', 'Traceability', 'Developer experience']
        motivations:
          [
            'Automate everything',
            'Connect systems end-to-end',
            'Eliminate manual steps',
            'Build self-healing pipelines',
          ]
        fears:
          [
            'Manual processes in automated pipelines',
            'Brittle integrations',
            'Lost traceability',
            'Shadow workflows outside CI/CD',
          ]
        decision_style: 'Automation-first, evaluates tools on API quality, reliability, and integration ease'
        information_sources:
          [
            'CI/CD documentation',
            'DevOps communities',
            'Infrastructure blogs',
            'GitHub Actions marketplace',
            'Vendor changelogs',
          ]
        communication_preferences: 'Pipeline-as-code, YAML configs, automated notifications, async collaboration'

    - id: 'product-ops-manager'
      name: 'Product Ops Manager'
      role: 'Product Operations Manager'
      description: >
        Manager responsible for product planning operations across multiple
        teams. Needs to initiate workflows for teams, monitor progress, and
        ensure planning cycles stay on schedule.
      goals:
        - 'Initiate READY phases for multiple teams from a single dashboard'
        - 'Pre-populate workflows with strategic context from prior cycles'
        - 'Track workflow initiation across teams for operational reporting'
        - 'Configure recurring workflow schedules for predictable planning cadence'
      pain_points:
        - 'Manually starting workflows for each team is time-consuming and error-prone'
        - 'No way to template common workflow configurations'
        - 'Cannot see which teams have started planning cycles vs. which are delayed'
        - 'Workflow initiation audit trail is incomplete or missing'
      usage_context: >
        Uses dashboard or API to initiate workflows at planning cycle start.
        Monitors initiation success across workspaces. Configures templates
        for common workflow patterns. Reports on planning cadence adherence.
      technical_proficiency: 'intermediate'
      current_situation: >
        As the product operations manager coordinating EPF cycles across 8 teams, I spend
        the first week of each quarter manually initiating READY phases. Each team requires
        different initial data based on their product context, and I copy-paste from prior
        cycles into YAML files with high error rates. I have no visibility into which teams
        have actually started their workflows vs. which are delayed. When leadership asks
        "how many teams have completed READY phase?", I manually check each workspace. There
        is no audit trail showing when workflows were initiated and by whom, making compliance
        reporting a nightmare.
      transformation_moment: >
        Using the workflow initiation API, I built a simple dashboard that shows all 8 teams
        with "Initiate READY" buttons. Each button calls POST /api/workflows with workspace_id
        and pre-configured initial_data from templates I maintain. Initiating all 8 teams now
        takes 2 minutes instead of 2 hours. The API returns workflow_id which I store for
        tracking. I can see initiation timestamps, who initiated each workflow, and which
        teams are pending. Quarterly planning coordination dropped from a week to a day.
      emotional_resolution: >
        Planning cycle operations are now streamlined and auditable. I initiate workflows
        confidently knowing the API validates my requests before creating them. Compliance
        reporting is trivial because I have complete initiation records. Teams receive
        workflows with correct initial data because templates prevent copy-paste errors.
        I am seen as enabling efficient planning rather than being a manual bottleneck.
        I have time for process improvement instead of spending it on repetitive initiation.
      demographics:
        age_range: '30-50'
        experience_years: '8-20 years in operations, program management, or product operations'
        company_size: 'Mid-market to Enterprise (500-10,000 employees)'
        industry:
          ['Technology', 'SaaS', 'Professional Services', 'Financial Services']
        geography: 'Corporate operations roles with cross-team coordination responsibilities'
        education: "Bachelor's or MBA in Business, Operations, or Project Management"
        reporting_structure: 'Reports to VP of Product, COO, or Head of Product Operations'
      psychographics:
        values:
          [
            'Operational efficiency',
            'Process consistency',
            'Auditability',
            'Team enablement',
          ]
        motivations:
          [
            'Streamline planning cycles',
            'Reduce manual coordination',
            'Enable team self-service',
            'Provide clear reporting',
          ]
        fears:
          [
            'Manual errors',
            'Inconsistent processes',
            'Audit trail gaps',
            'Being a bottleneck',
          ]
        decision_style: 'Process-oriented, values templates and consistency over ad-hoc flexibility'
        information_sources:
          [
            'Dashboards',
            'Process documentation',
            'Team feedback',
            'Leadership requirements',
            'Ops community best practices',
          ]
        communication_preferences: 'Structured workflows, status dashboards, automated notifications, clear escalation paths'

    - id: 'external-integration-developer'
      name: 'External Integration Developer'
      role: 'Third-Party Integration Developer'
      description: >
        Developer building integrations between EPF and external tools like
        Jira, Linear, or custom internal systems. Needs well-documented API
        with clear authentication and error handling patterns.
      goals:
        - 'Trigger EPF workflows when external events occur (Jira epic created, etc.)'
        - 'Sync workflow status back to external systems for visibility'
        - 'Map external system data structures to EPF workflow parameters'
        - 'Handle authentication securely for multi-tenant deployments'
      pain_points:
        - 'No standard way to connect external tools to EPF workflow lifecycle'
        - 'API documentation is incomplete or missing for integration use cases'
        - 'Authentication patterns differ between endpoints, causing confusion'
        - 'Rate limits and error handling behavior is undocumented'
      usage_context: >
        Builds webhook handlers that receive events from Jira/Linear and call
        the workflow API. Implements bidirectional sync between EPF and external
        project management tools. Uses multiple API keys for different tenants.
      technical_proficiency: 'advanced'
      current_situation: >
        As an integration developer building connections between EPF and our Jira instance,
        I want to trigger FIRE phases when Jira epics are created in specific projects. But
        there is no documented API for workflow initiation, so I am guessing at endpoints
        and parameters based on network inspection. Authentication is unclear - I found API
        keys mentioned in one place but OAuth tokens in another. My integration breaks
        frequently because API behavior changes without notice. Error responses are
        inconsistent, making my error handling code fragile. Building reliable EPF
        integrations is more frustrating than it should be.
      transformation_moment: >
        The workflow initiation API documentation included complete examples for my use case:
        trigger workflow on external event, pass event data as initial_data, monitor status
        for sync-back. Authentication is simple - one API key per workspace in Authorization
        header. Error responses follow a consistent schema with codes I can handle reliably.
        My Jira webhook handler now creates FIRE phases when epics are created, and my status
        sync keeps Jira issues updated with EPF workflow progress. What took weeks of
        reverse-engineering now takes days of implementation.
      emotional_resolution: >
        Building EPF integrations is now predictable and satisfying. Clear documentation
        means I implement features instead of debugging authentication mysteries. Consistent
        error handling lets me build robust integrations that handle edge cases gracefully.
        My Jira integration runs reliably in production, and stakeholders see EPF as
        integrated with their existing tools rather than a separate system. I can estimate
        integration work accurately because I know what the API supports. Integration
        development is a joy rather than a frustration.
      demographics:
        age_range: '25-40'
        experience_years: '3-12 years in software development, often with integration focus'
        company_size: 'Startups to Mid-market (50-2,000 employees)'
        industry:
          ['Technology', 'SaaS', 'Integration Platforms', 'Enterprise Software']
        geography: 'Global, often working with partner ecosystems'
        education: "Bachelor's in Computer Science or self-taught developer"
        reporting_structure: 'Reports to Engineering Lead, CTO, or Partner Integration Manager'
      psychographics:
        values:
          [
            'API quality',
            'Documentation clarity',
            'Reliable integrations',
            'Developer experience',
          ]
        motivations:
          [
            'Build working integrations quickly',
            'Create seamless connections',
            'Reduce customer friction',
            'Master new platforms',
          ]
        fears:
          [
            'Undocumented APIs',
            'Breaking changes',
            'Inconsistent error handling',
            'Integration certification failures',
          ]
        decision_style: 'Documentation-first, evaluates platforms on API design, error handling, and support quality'
        information_sources:
          [
            'API documentation',
            'Developer portals',
            'Support channels',
            'Code samples',
            'Community forums',
          ]
        communication_preferences: 'Self-service docs, sandbox environments, responsive support, clear versioning'

  capabilities:
    - id: 'cap-001'
      name: 'Workflow Creation Endpoint'
      description: >
        POST /api/workflows endpoint accepts phase type (READY/FIRE/AIM), workspace ID, and optional initial data. Returns workflow ID within 500ms for monitoring and status checks.

    - id: 'cap-002'
      name: 'Request Validation'
      description: >
        Validates workspace ID exists, phase type is valid (READY/FIRE/AIM), and optional data matches expected schema. Returns detailed error messages with field-level validation failures.

    - id: 'cap-003'
      name: 'Idempotent Workflow Creation'
      description: >
        Supports idempotency keys in request headers to prevent duplicate workflows. If same key sent twice, returns existing workflow ID instead of creating duplicate.

    - id: 'cap-004'
      name: 'API Key Authentication'
      description: >
        Authenticates requests using API keys in Authorization header. Each key scoped to specific workspace(s) and rate-limited to prevent abuse.

implementation:
  design_guidance:
    principles:
      - 'Simple over Complex: Minimal required fields, sensible defaults for optional parameters'
      - 'Immediate Feedback: Return workflow ID synchronously, async execution happens afterward'
      - 'Predictable Errors: Consistent error format with field-level details for debugging'
      - 'Integration First: Designed for machines (agents, pipelines) with human dashboard as secondary'

    inspirations:
      - 'Stripe API for consistent error formats and idempotency patterns'
      - 'Temporal API for workflow lifecycle management'
      - 'GitHub Actions API for CI/CD integration patterns'

    interaction_patterns:
      - 'POST request with JSON body containing phase_type and workspace_id'
      - 'Authorization header with Bearer token for API key authentication'
      - 'Idempotency-Key header for safe retry semantics'
      - 'JSON response with workflow_id, status, and created_at timestamp'

  contexts:
    - id: 'ctx-001'
      type: 'api'
      name: 'Workflow Initiation Endpoint'
      description: |
        RESTful API endpoint for creating new EPF workflow instances. Accepts JSON payloads with workflow parameters, validates input, creates Temporal workflow, and returns workflow identifier. Primary integration point for AI agents, DevOps pipelines, and no-code automation tools.
      key_interactions:
        - 'POST /api/workflows - Create new workflow with phase type and workspace ID'
        - 'Include Authorization: Bearer {api_key} header for authentication'
        - 'Include Idempotency-Key: {uuid} header for retry safety'
        - 'Handle 201 Created (success), 400 Bad Request (validation), 401 Unauthorized (auth), 404 Not Found (workspace)'
        - 'Parse JSON response containing workflow_id, status, created_at fields'
      data_displayed:
        - 'workflow_id: Unique identifier for monitoring (string, format: wf-{random})'
        - 'status: Current state (enum: initiated, in_progress, completed, failed)'
        - 'created_at: Timestamp of workflow creation (ISO 8601 format)'
        - 'phase_type: Which EPF phase this workflow executes (READY/FIRE/AIM)'
        - 'workspace_id: Workspace scope for this workflow (string)'
        - 'errors: Array of validation errors if request fails (4xx responses)'

    - id: 'ctx-002'
      type: 'ui'
      name: 'Workflow Monitoring Dashboard'
      description: |
        Web UI showing real-time status of all workflows across user's authorized workspaces. Displays workflow list with filtering, individual workflow details with timeline, and export capabilities. Primary interface for monitoring programmatically-initiated workflows.
      key_interactions:
        - 'Filter workflows by status (initiated, in_progress, completed, failed)'
        - 'Filter workflows by phase type (READY, FIRE, AIM)'
        - 'Filter workflows by workspace (multi-select dropdown)'
        - 'Sort by created_at, completed_at, or alphabetically by workspace name'
        - 'Click workflow row to view detailed timeline and artifact status'
        - 'Export filtered workflow list to CSV for reporting'
        - 'View API-initiated vs manually-created workflow distinction'
      data_displayed:
        - 'Workflow list table: ID, workspace, phase, status, created date, completion date'
        - 'Status badges with color coding (green: completed, yellow: in-progress, red: failed, blue: initiated)'
        - "Workflow count per status category (e.g., '5 in progress, 12 completed today')"
        - 'Detailed timeline showing workflow steps: which completed, which pending, which failed'
        - 'Initiator information: API key name, automation source (GitHub Actions, Zapier, etc.)'
        - 'Real-time updates via WebSocket (no page refresh needed for status changes)'

    - id: 'ctx-003'
      type: 'api'
      name: 'CI/CD Pipeline Integration'
      description: |
        Pattern for integrating EPF workflow initiation into continuous integration and deployment pipelines. Demonstrates API usage in GitHub Actions, GitLab CI, CircleCI, and Jenkins. Provides reusable scripts and action definitions for common CI platforms.
      key_interactions:
        - 'Store API keys in CI secrets/environment variables (never hardcode)'
        - 'Generate idempotency keys from deterministic pipeline metadata (PR ID, commit SHA, job ID)'
        - 'Construct API request with pipeline metadata in initial_data payload'
        - 'Handle API response: success (2xx) â†’ continue, failure (4xx) â†’ fail job with error'
        - 'Post workflow_id back to PR comments, commit statuses, or chat notifications'
        - 'Implement exponential backoff retry for transient API failures (5xx)'
      data_displayed:
        - 'CI logs showing API request/response (sanitized API keys)'
        - 'Pipeline job status: Success with workflow_id or Failure with error details'
        - 'PR comments with workflow link and status badge'
        - "Commit status check showing 'EPF workflow initiated' with link"
        - 'Chat notifications (Slack, Teams) with workflow details'

  scenarios:
    - id: 'scn-001'
      name: 'AI Agent Initiates READY Phase Workflow'
      actor: "AI Autonomy Engineer's AutoPlan Agent"
      context: 'Agent has analyzed market data for new product opportunity and generated initial strategy recommendations. Agent needs to start EPF READY phase to structure planning artifacts.'
      trigger: "Agent's orchestration layer decides sufficient market analysis complete to begin structured planning"
      action: |
        1. Agent constructs API request with workspace_id (from agent config), phase_type: "READY", and optional initial_data containing market analysis summary
        2. Agent includes API key in Authorization header and generates idempotency key (UUID) for retry safety
        3. Agent sends POST request to /api/workflows endpoint
        4. Agent receives JSON response with workflow_id, status: "initiated", and created_at timestamp
        5. Agent stores workflow_id in internal state for subsequent status monitoring
        6. Agent logs successful workflow initiation with workflow_id for debugging
      outcome: |
        API returns workflow_id: "wf-abc123" with 201 Created status within 450ms. Temporal workflow is created and begins executing READY phase steps. Agent can immediately query workflow status via GET /api/workflows/wf-abc123. Dashboard shows new workflow in "initiated" state for workspace.
      acceptance_criteria:
        - 'API responds within 500ms with 201 Created status'
        - 'Response includes workflow_id (string), status (string), created_at (ISO 8601 timestamp)'
        - 'Temporal workflow is created and visible in Temporal UI within 1 second'
        - 'Workspace dashboard shows new workflow in real-time (no page refresh needed)'
        - 'Idempotency: Sending same idempotency key returns existing workflow_id with 200 OK'

    - id: 'scn-002'
      name: 'DevOps Pipeline Triggers FIRE Workflow'
      actor: 'CI/CD Pipeline System'
      context: 'GitHub Actions workflow running after feature branch PR merged to main. Pipeline needs to initiate FIRE phase to track feature implementation.'
      trigger: "GitHub Actions 'on: pull_request: types: [closed]' event with merged=true"
      action: |
        1. GitHub Actions script extracts PR metadata (feature name, description, assignees)
        2. Script calls API with workspace_id, phase_type: "FIRE", feature_name from PR title, and assignees as contributors
        3. Script includes team API key (stored in GitHub Secrets) and generates idempotency key from PR ID
        4. Script handles API response: Success (201) â†’ logs workflow_id; Error (4xx) â†’ fails job with error details
        5. On success, script posts comment to PR with workflow_id and link to status dashboard
      outcome: |
        API creates FIRE workflow and returns workflow_id within 400ms. PR comment appears with message: "ðŸš€ EPF FIRE workflow initiated: wf-def456. Track progress: https://epf-runtime.example.com/workflows/wf-def456". Team members see workflow in their dashboard. Pipeline job completes successfully.
      acceptance_criteria:
        - 'API accepts feature metadata in initial_data payload'
        - 'Response includes workflow_id that can be shared via PR comment'
        - 'Pipeline job succeeds when API returns 2xx status'
        - 'Pipeline job fails with clear error when API returns 4xx (invalid workspace, bad auth, etc.)'
        - "Error responses include actionable error message and affected fields (e.g., 'workspace_id: not found')"

    - id: 'scn-003'
      name: 'Startup Founder Initiates Retrospective via Zapier'
      actor: 'Startup CTO via Zapier Automation'
      context: 'Deployment completed to production. Zapier monitors deployment webhook from hosting platform. CTO configured Zap to trigger AIM retrospective after successful deployments.'
      trigger: 'Zapier receives deployment success webhook from Vercel/Netlify'
      action: |
        1. Zapier Webhook trigger captures deployment metadata (version, timestamp, deployed_by)
        2. Zapier HTTP Request action sends POST to /api/workflows with workspace_id, phase_type: "AIM", deployment_metadata
        3. Zapier includes API key from configuration and generates idempotency key from deployment ID
        4. On success, Zapier sends Slack message to #product channel: "ðŸŽ¯ Retrospective workflow started for v2.4.0: [workflow link]"
        5. On failure, Zapier sends Slack DM to CTO with error details
      outcome: |
        API creates AIM workflow and returns workflow_id. Slack message appears in #product channel with link. Team clicks link to view retrospective dashboard. Workflow prompts team to complete assessment artifacts. No-code automation successfully initiated EPF cycle.
      acceptance_criteria:
        - 'API accepts arbitrary metadata in initial_data for retrospective context'
        - 'No-code tools (Zapier, Make) can successfully call API using HTTP Request actions'
        - 'Idempotency works across multiple automation retry attempts'
        - 'Error responses are human-readable for Slack notification (not just error codes)'
        - 'Workflow starts within 5 seconds of deployment completion'

    - id: 'scn-004'
      name: 'Research Lead Monitors Cross-Project Workflow Status'
      actor: 'Product Research Lead'
      context: 'Research lead opens EPF Runtime dashboard to review workflow status across all 8 projects she oversees. Three workflows were initiated via API overnight by automated systems.'
      trigger: 'Research lead navigates to /dashboard after morning standup meetings'
      action: |
        1. User sees workflow list showing 8 active workspaces with workflow counts
        2. User filters by status: "in_progress" to see active workflows (5 shown)
        3. User clicks Project Alpha's READY workflow (initiated 2 days ago) to view details
        4. Dashboard loads workflow timeline showing completed steps, current step (pending artifact validation), and estimated completion
        5. User exports workflow data to CSV for quarterly reporting
      outcome: |
        User identifies that Project Alpha's READY phase is blocked waiting for stakeholder input (artifact validation pending). User messages project lead to unblock. Dashboard shows real-time status for all workflows initiated via API. CSV export contains workflow metadata for trend analysis.
      acceptance_criteria:
        - 'Dashboard displays workflows initiated via API alongside any manual workflows'
        - 'Status values (initiated, in_progress, completed, failed) are consistent with API responses'
        - 'Workflow timeline shows which steps were automated vs manual'
        - 'Dashboard loads within 2 seconds even with 50+ workflows across 8 workspaces'
        - 'CSV export includes workflow_id, workspace, phase, status, created_at, completed_at fields'

  external_integrations:
    - name: 'Temporal'
      purpose: 'Create and manage durable workflow executions'
      direction: 'outbound'

    - name: 'GitHub Actions'
      purpose: 'Trigger workflows from CI/CD pipeline events'
      direction: 'inbound'

    - name: 'Zapier/Make'
      purpose: 'No-code automation for workflow triggers'
      direction: 'inbound'

boundaries:
  non_goals:
    - 'Workflow status polling (covered by separate Status Monitoring API)'
    - 'Workflow cancellation or modification (deferred to Phase 2)'
    - 'Artifact upload during initiation (workflows start empty, artifacts added in later steps)'
    - 'Temporal workflow execution logic (this is API interface only, not workflow definitions)'
    - 'Dashboard UI implementation details (covered by separate Workflow Dashboard)'
    - 'WebSocket real-time updates (uses HTTP polling in MVP, WebSocket in Phase 2)'
    - 'GraphQL endpoint (REST only in MVP, GraphQL wrapper added later)'

  constraints:
    - 'API rate limit: 100 requests per minute per API key'
    - 'Maximum initial_data payload size: 10KB (larger data passed via artifact upload endpoints)'
    - 'Workflow initiation timeout: Must respond within 500ms or return 503 Service Unavailable'
    - 'Idempotency key TTL: 24 hours (after that, duplicate key creates new workflow)'
    - 'Supported phase types: READY, FIRE, AIM only (custom phases not supported in MVP)'
    - 'Authentication: API key only (OAuth2/JWT deferred to Phase 2)'
    - 'Workspace limit: 100 active workflows per workspace (Enterprise plan: 500)'

dependencies:
  requires:
    - id: 'fd-001'
      name: 'Knowledge Graph Engine'
      reason: 'Workflow metadata (workspace associations, artifact references, stakeholder assignments) must be stored in the knowledge graph for semantic querying and relationship tracking'
    - id: 'fd-007'
      name: 'Authentication & Multi-Tenancy'
      reason: 'API keys must be scoped to specific workspaces and rate-limited to prevent abuse'
  enables:
    - id: 'fd-011'
      name: 'EPF Schema Validation Service'
      reason: 'Once workflows are initiated programmatically, validation must happen automatically during workflow execution'
    - id: 'fd-012'
      name: 'CLI for Local Workflow Testing'
      reason: 'Developers need to test workflow initiation locally before deploying to CI/CD pipelines'
